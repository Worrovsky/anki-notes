## 001. Символы `.` и `?` в regex. Экранирование.


`.` - означает любой символ (кроме перевода строки)
`?` - означает опциональность: предыдущий символ или его отсутствие

Экранирование: `\\`

```kt
val regex = Regex("cats\\?")
val s = "cars?"
s.matches(regex) // true
```


[id](002.004.001)


## 002. Создание объекта Regex и проверка.


2 способа создания:
* из строки через **toRegex()**
* через конструктор **Regex()**

```kt
val s = "cat"
val regex1 = s.toRegex()
val regex2 = Regex(s)
```

Проверка через ф-ю **matches()** `fun String.matches(regex: Regex): Boolean`

```kt
val regex = "a..".toRegex()
val test = "abc".matches(regex)
```


[id](002.004.002)


## 003. Наборы символов в regex. Диапазоны.


**Набор** - перечень символов, соответствие одному символу в строке:

```kt
val regex = Regex("[bcr]at") 
"rat".matches(regex) // true
```

**Диапазон** - последовательность символов, как они указаны в ASCII- или Unicode-таблицах.

Например цифры, символы алфавита последовательно расположены: `[0-9]`, `[a-z]`, `[A-Z]`. Но `[A-z]` содержит дополнительные символы, поэтому правильнее `[a-zA-Z]`

В диапазоны можно вставлять любые символы, экранирование не нужно: `[a-z!.?]`


[id](002.004.003)


## 004. Исключение символов через `^`


Работает в наборах, диапазонах: `[^abc]`, `[^a-z]`


[id](002.004.004)


## 005. Специальные символы в диапазонах: `.?-^[]`


`.` или `?` специально экранировать не нужно, можно просто использовать внутри диапазона: `[a-z?]`

`^` - имеет специальное значение (исключение) только в начале, в остальных позициях будет считаться простым символом: `[^a-z^]`

`-` можно помещать до или после диапазона: `[a-z-]`, `[-A-Z]`

`[` и `]` нужно экранировать: `[\\[\\]]`


[id](002.004.005)


## 006. Указание альтернатив в regex. Отличие от наборов.


Альтернативные варианты указываются через `|`:

```kt
val regex = "yes|no|maybe".toRegex() 
"no".matches(regex) // true
```

В отличие от наборов можно задавать не отдельные символы, а строки:
```kt
val regex1 = "(y|n|m)ax".toRegex() 
val regex2 = "[ynm]ax".toRegex() 
"nax".matches(regex1) // true
"yax".matches(regex2) // true
```


[id](002.004.006)


## 007. Сокращения для regex: цифры, буквы, пустые, границы слов


**\d** - цифры (**d**igits), эквивалент `[0-9]`

**\s** - пустое пространство (**s**pace), эквивалент `[\t\n\x0B\f\r]`

**\w** - буква или цифра или `_` (**w**ord), эквивалент - `[a-zA-Z_0-9]`

**\b** - границы слов (**b**oundary). Соответствует не какому-то символу, а переходу между цифробуквенным символом и не цифробуквенным, т. е. граница между началом и концом слова. Например `\ba` - все слова, начинающиеся с `a`, `a\b` - заканчивающиеся на `а`.

Заглавные буквы - инверсия: **\D** - НЕ цифры, **\S**, **\W**, **\B**

В Kotlin нужно экранировать: `\\d\\w` или использовать raw-строки: `"""\d\w"""`


[id](002.004.007)


## 008. Квантификаторы в regex


Проверяют количество вхождений предыдущего символа (группы)

Значения: 

* **+** - одно или более вхождение
* ***** -  0 или более вхождение
* **{n}** - конкретное количество вхождений
* **{n,m}** - количество вхождений >= n и <= m
* **{n,}** - количество вхождений >= n
* **{0,m}** - количество вхождений не больше m

Примеры:

```kt
val regex = "ca+b".toRegex()

regex.matches("cab") // true
regex.matches("caaaaab") // true
regex.matches("cb") // false
```
```kt
val regex = "A[0-3]*".toRegex()
regex.matches("A")  // true
regex.matches("A0") // true
regex.matches("A000111222333") // true

val johnRegex = ".*John.*".toRegex() // любая строка, содержащая John
```

```kt
val regex = "[0-9]{4}".toRegex() 
regex.matches("6342")  // true
regex.matches("182")   // false
```


[id](002.004.008)


## 009. Использование regex в разных функциях работы со строками


1. Ф-я **split()** разделяет строку по regex и возвращает список подстрок

```kt
fun CharSequence.split(
     regex: Regex,
    limit: Int = 0
): List
```

```kt
val brackets = "+1-(213)-345-6789"
val s = brackets.split("(-\\(|\\)-|-)".toRegex()) 
// {"+1", "213", "345", "6789"}
```
2. Ф-я **replace()**:
```kt
fun CharSequence.replace(
    regex: Regex,
    replacement: String
): String
```
```kt
// замена чисел на слово
val processedString = withDigits.replace("\\d+".toRegex(), "[digits]")
```

3. Ф-и **find()** и **findAll()** находит первое вхождение или все, соответствующие regex.

```kt
val regex = """\d{4}-\d{2}-\d{2}""".toRegex() 
val matchResult =
    regex.findAll("Harry was born 1980-07-31 in the Godric's Hollow."
for (matches in matchResult) println(matches.value)
```


[id](002.004.009)