## 001. Синтаксис объявления функций. Возможности объявления параметров. Разные случаи объявления параметров: * переопределение метода с параметрами по умолчанию * вызов для комбинации параметров с дефолтными значениями и без * вызов функции с последним параметром-лямбдой


Объявление через ключевое слово **fun**:
```kt
fun double(x: Int): Int {
    return x * 2
}
```
Параметры:
* нотация в стиле Pascal (`<имя>: <Тип>`)
* можно использовать *trailing comma*
* можно параметры по умолчанию
* можно именованные параметры

Если **метод с параметрами по умолчанию переопределяется**, в новом методе эти параметры не могут иметь значений по умолчанию:
```kt
open class A {
    open fun foo(i: Int = 42) { .. }
}
class B: A() {
    override fun foo(i: Int) { .. }
}
``` 

Если в объявлении функции **есть параметры с дефолтными значениями и без**, вызов со значениями по умолчанию возможен только через именованные параметры:
```kt
fun foo(bar: Int = 10, baz: Int) { .. }
foo(baz = 6)
```

Если **последний параметр функции - это лямбда**, при вызове ее можно передать через именованный параметр или вынести за скобки:
```kt
fun foo(
    bar: Int = 0,
    baz: Int = 1,
    qux: () -> Unit,
) { .. }

foo(1) { println("Hello")
foo(qux = { println("Hello") }
foo { println("Hello") }
```


[id](001.004.001)


## 002. Что такое **Unit**. Литерал. Синтаксис функций, возвращающих **Unit**


**Unit** - специальный тип с единственным значением **Unit**.

Означает что функция ничего не возвращает.

В синтаксисе указание **Unit** опционально как и явное указание оператора `return`:
```kt
fun foo(): Unit {
    println("Hello")
    return
}

fun foo() { 
    println("Hello")
}
```


[id](001.004.002)


## 003. Синтаксис для функций с телом в виде единственного выражения (**single-expression function**). Когда обязательно указание возвращаемого типа.


Тело функции может содержать единственное выражение (**single-expression function**). В этом случае можно:
* опустить скобки и указать тело через `=`
* не указывать тип возвращаемого значения
```kt
fun double(x: Int) = x * 2
```

Если тело функции заключено в фигурные скобки и возвращаемый тип не **Unit**, указание типа обязательно (сложно для компилятора вывести из-за возможных ветвлений и т. п.):
```kt
fun sum(a: Int, b: Int): Int {
    return a + b
}
// но
fun sum(a: Int, b: Int) = a + b
```


[id](001.004.003)


## 004. Синтаксис указания произвольного количества аргументов в функциях (**varargs**). Как вызвать, какой тип внутри функции. **Spread**-оператор. Как для массивов примитивных типов.


Синтаксис **varargs-аргументов** - модификатор `vararg`.
```kt
fun <T> asList(vararg ts: T): List<T> {
    var result = ArrayList<T>()
    for (t in ts) { // ts это массив
        result.add(t)
    }
    return result
}
```
Вызывать теперь можно с произвольным количеством аргументов. Внутри функции тип -  массив:
```kt
val list = asList(1, 2, 3, 4)
```
Условия для использования:
* только один параметр может быть с таким модификатором
* если он не последний в списке параметров - вызов через именованный аргумент

Вместо перечня значений можно передать массив, но с **spread**-оператором `*`:
```kt
val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
```

Примитивные массивы нужно преобразовывать в типизированные:
```kt
val a = intArrayOf(1, 2, 3) // массив примитивных типов
val list = asList(-1, 0, *a.toTypedArray(), 4)
```


[id](001.004.004)


## 005. Инфиксная нотация (**infix**): для чего, требования, синтаксис. Приоритет инфиксных функций в связке с арифметическими операторами, операторами преобразования типа, логическими операторами.


Используется для упрощения вызова функции: можно опускать точку и скобки.

Требования к функции, чтобы можно было объявить инфиксной:
* это функция - член класса или функция-расширение
* должна иметь только один параметр
* этот параметр - не *vararg* и без значения по умолчанию

```kt
infix fun Int.shl(x: Int): Int { .. }
// вызов:
1 shl 2
// или то же самое
1.shl(2)
```

Приоритет инфиксных функций:
* ниже, чем:
    - арифметические операторы
    - операторы приведения типа
    - операторы работы с диапазонами
* но выше, чем 
    - логические
    - проверки вхождения в диапазон
```kt
1 shl 2 + 3 // 1 shl (2 + 3)
xs union ys as Set<*> // xs union (ys as Set<*>)
a &amp;&amp; b xor c // a &amp;&amp; (b xor c)
a xor b in c // ( a xor b) in c
```


[id](001.004.005)


## 006. 3 типа объявления функций (по месту объявления). Область видимости локальных функций.


Функции можно объявлять:
* на верхнем уровне (не обязательно в классах, как в Java)
* локально (внутри других функций)
* внутри классов или объектов

Локальные функции имеют доступ к локальным переменным функций, в которых они объявлены:
```kt
fun foo() {
    val bar = "qux"
    fun baz() {
        println(bar)
    }
}
```
Функции-члены класса имеют доступ к другим членам класса, в т. ч. приватным


[id](001.004.006)


## 007. Что такое **higher-order function**. Какой тип у функций. Примеры с параметрами / без, с пустым значением. Как объявить тип функции, возвращающей nullable-тип. Ассоциация типов.


**higher-order function** - это функции, принимающие другие функции в качестве параметра, или возвращающие функции.

Тип функции показывает сигнатуру функции - параметры и возвращаемые значения:
* перечень типов параметров в скобках и возвращаемый тип `(A, B) -> C`
* список параметров может быть пустым, но скобки обязательны `() -> A`
* Тип **Unit** не может быть опущен `() -> Unit`
* через **.** опционально может указываться тип получателя (*receiver*), на объекте которого вызывается функция: `A.(B) -> C`
* **suspend**-функции дополнительно обозначаются модификатором `suspend () -> Unit`

Можно указывать именованные параметры, но это только для удобства / документации. Конкретная функция может иметь любые имена параметров.

Функция, возвращающая nullable-тип:
```kt
((Int, Int) -> Int)?
```

Для типов **higher-order** функций можно использовать скобки. Но вообще типы ассоциируются справа налево:
```kt
// эти типы эквивалентны
(Int) -> ((Int) -> Unit) 
(Int) -> (Int) -> Unit
```


[id](001.004.007)


## 008. Как получить экземпляр функции заданного типа (3 основых метода).


Варианты создания функционального типа:
* блок кода в литерале функции:
    - **лямбда-функция** `{ a, b -> a + b }`
    - **анонимная функция** `fun(s: String): Int { return s.length }`
* использование ссылки на существующее определение
    - **функции** на верхнем уровне, локальной или члене класса `::isOdd`, `String::toInt`
    - **свойства** на верхнем уровне, класса `List<Int>::size`
    - **конструктора** `::Regex`
* использование класса, реализующего функциональный тип:
```kt
class IntTransformer: (Int) -> Int {
    override operator fun invoke(x: Int): Int { ... }
}
val intFunction: (Int) -> Int = IntTransformer()
```

Тип функции можно не указывать, если компилятор сможет вывести:
```kt
val a = { i: Int -> i + 1 } // тип (Int) -> Int
```


[id](001.004.008)


## 009. Вызов экземпляра переменной функционального типа (2 способа). Особенности вызова функций, объявленных с типом приемника.


У каждой переменной функционального типа есть метод **invoke()**.

Или обычным способом `f()`.

```kt
val stringPlus: (String, String) -> Strihg = String::plus
val s1 = stringPlus.invoke("ab", "cd") 
val s2 = stringPlus("ab", "cd") 
```

Если тип функции объявлен с типом приемника (`A.(B) -> C)`, вызывать можно как и обычную функцию, но первым параметром должен быть передан объект-приемник. Дополнительно можно вызвать в форме `1.foo(2)`:

```kt
val intPlus: Int.(Int) -> Int = Int::plus
val x1 = intPlus.invoke(1, 2)
val x2 = intPlus(2, 3)
val x3 = 3.intPlus(4)
```


[id](001.004.009)


## 010. 2 вида функциональных литералов. Синтаксис лямбда-выражений.


Функциональные литералы не объявляют функции (не дают им имя), а сразу передают как выражение. Два вида:
* лямбда-выражения
* анонимные функции

Синтаксис лямбда-выражений:
* всегда в фигурных скобках
* параметры объявляются внутри скобок, типы параметров опциональны
* тело объявляется после `->`
* если тип выражения не `Unit`, тип всего лямбда-выражения определяется последним выражением в теле
```kt
val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }
// упрощенно
val sum = { x: Int, y: Int -> x + y }
```


[id](001.004.010)


## 011. Что такое **trailing lambda**.


Соглашение, при котором если последний параметр функции - функция, тогда лямбда, передающаяся в этот параметр может быть вынесена за скобки:
```kt
val product = items.fold(1) { acc, e -> acc * e }
```
Если такой параметр единственный - скобки параметров могут быть опущены:
```kt
run { println(...) }
```


[id](001.004.011)


## 012. Параметр **it** в лямбда-выражениях.


Часто лямбда-выражение содержит только один параметр. Тогда объевление параметров можно опустить, а в теле использовать специальное имя **it**:
```kt
ints.filter { it > 0 }
```


[id](001.004.012)


## 013. Как выполнить возврат в лямбда-выражении: 2 варианта. Общие правила использования оператора **return** применительно к лямбдам и анонимным функциям. Локальные и нелокальные возвраты.


Вариант первый: неявно возвращается результат последнего выражения в теле:
```kt
ints.filter { 
    val shouldFilter = it > 0
    shouldFilter
}
```
Вариант второй: использование **qualified return** синтаксиса. Если просто указать `return` - это возврат из внешней функции, в которой вызвана функция с лямбда-выражением (оператор `return` по умолчанию выполняет возврат из ближайшей функции, объявленной явно с модификатором `fun`):
```kt
fun foo() {
    ints.filter {
        val shouldFilter = it > 0
        return@filter shouldFilter
       // просто return - тогда возврат из foo() 
   }
}
```

Правила оператора **return**:
* нельзя напрямую использовать для лямбд, которые передаются не в inline-функцию.
* простой вызов **return** означает *нелокальный возврат*: выход из блока, ограниченного модификатором **fun**:
    - для лямбда-выражений это означает выход из внешней функции
    - для анонимных - из самой анонимной функции
* для локального возврата в лямбда-выражениях нужно использовать выход по меткам `return@label`:
    - с явной установкой метки `people.forEach label@ { ... }`
    - либо с использованием имени функции, содержащей лямбда-выражение


[id](001.004.013)


## 014. Имя для неиспользуемого параметра лямбда-выражения.


Если параметр неиспользуется, можно через `_` задать имя:
```kt
map.forEach { _, value -> println("" + value) }
```


[id](001.004.014)


## 015. Анонимные функции. Зачем нужны (когда лямбды недостаточно). Особенности синтаксиса. Отличия от лямбд.


Главное отличие **анонимных функций** от лямбда-выражений: позволяют определить возвращаемый тип функции. В лямбдах он выводится автоматически, но иногда нужно явно:
```kt
fun(x: Int, y: Int): Int = x + y
```
Синтаксис - полностью как у обычных функций, но:
* без указания имени
* можно опустить типы параметров, если их можно вывести
```kt
ints.filter(fun(item) = item > 0)
```
Отличия от лямбда-выражений:
* нельзя выносить параметр за скобки, как для лямбды
* оператор `return` напрямую возвращает управление из анонимной функции, не внешней как для лямбд


[id](001.004.015)


## 016. Что такое **closure** (замыкание). У каких конструкций есть.


Возможность доступа внутри некоторых конструкций языка (например лямбда-выражений) к переменным, обвъявленным во внешней области видимости.

Доступно для:
* лямбда-выражений
* анонимных функций
* локальных функций
* объектов-выражений

```kt
var sum = 0
ints.filter { it > 0 }.forEach {
    sum += it
}
print(sum)
```
Захватываемые переменные не должны быть финальными как в Java. После объявления функции, переменные можно изменять, изменения будут видны внутри функции.


[id](001.004.016)


## 017. Что такое функциональные литералы с получателями (receivers). Синтаксис объявления. Пример для StringBuilder.buildString. Отличия в вызове таких функций. Как понять какого типа лямбда в конкретной переменной. Пример анонимной функции с получателем (сумма двух целых)


Позволяют присвоить одному из параметров функции специальный статус получателя и вызывать его методы без явной ссылки или через **this**. Обеспечивается это через передачу экземпляра этого объекта внутрь функции.

Для объявления при указании типа необходимо вынести тип получателя за скобки параметров и отделить **.**: `StringBuilder.() -> Unit`.

Вот пример без использования получателей:
```kt
fun buildString(buildAction: (StringBuilder) -> Unit): String {
    val sb = StringBuilder()
    buildAction(sb)
    return sb.toString()
}
val s = buildString {
    it.append("Hello, ")
    it.append("world")
}
```
А вот с использованием получателя:

```kt
fun buildString(builderAction: StringBuilder.() -> Unit): String {
    val sb = StringBuilder()
    sb.builderAction()
    return sb.toString()
}
```
Теперь в определении функции (лямбда или анонимной) есть доступ к объекту-получателю и можно вызывать его методы напрямую или через ссылку **this**:
```kt
val s = buildString { 
        this.append("Hello, ")
        append("world")
}
```
Отличия в вызове: обычная функция вызывается сама по себе с передачей объекта в аргументе, функция с получателем - на объекте (как функции-расширения).

Чтобы понять какого типа лямбда-функция, нужно смотреть объявление типа, только так.

Аналогично для анонимных функций:
```kt
val sum = fun Int.(other: Int): Int = this + other
val s = 6.sum(100)
```


[id](001.004.017)


## 018. Для чего нужны inline-функции (встроенные). Синтаксис. Встраивание параметров (лямбд) inline-функций.


Лямбда-выражения вносят дополнительные накладные расходы:
* лямбда-выражения компилируются в анонимные классы
* если хранит переменные - на каждый вызов - новый объект (захват closure)

Функция с модификатором **inline** не компилируется в дополнительный объект. Ее тело просто вставляется в место вызова.

Функция, объявляется встроенной:
```kt
inline fun <T> synchronized(lock: Lock, body: () -> T): T { .. }
```
Вызов функции и эквивалентный код:
```kt
synchronized(l) { foo() }
// эквивалент:
l.lock()
try {
    foo()
} finally {
    l.unlock()
}
```

Параметры (в виде лямбд) inline-функций также могут встраиваться, но только если они известны в момент вызова.
```kt
// здесь тело ф-и synchronized будет встроено
// а тело метода body нет: оно еще не известно
class LockOwner(val lock: Lock) {
    fun run(body: () -> Unit() {
        synchronized(lock, body)
    }
}
```


[id](001.004.018)


## 019. Ограничения встраиваемых функций. Как запретить встраивание некоторых параметров.


Если функция встраиваемая, тогда тело лямбда-выражения из параметра также встраивается напрямую в код.

Поэтому нельзя встраивать лямбды, которые предполагается сохранить и передать для дальнейшего использования.

Можно только если:
* параметр непосредственно вызывается в теле inline-функции
* или передается в другую inline-функцию

Для запрета встраивания отдельных параметров - модификатор **noinline**:
```kt
inline fun foo(inlined: () -> Unit, noinline noinlined: () -> Unit) { ... }
```


[id](001.004.019)


## 020. 3 преимущества inline-функций.


Преимущества:
1. т. к. встраиваются - нет накладных расходов на вызов
2. лямбды, переданные во встраиваемые функции - также становятся встраиваемыми (т. е. не создаются объекты для хранения лямбд), но только, если переданы для использования
3. универсальные параметры можно овеществлять (**reified**)


[id](001.004.020)


## 021. Где обычно объявляются объекты-расширения. Как вызвать в других местах


Как правило расширения объявляются на верхнем уровне отдельных пакетов:
```kt
package org.example.declarations

fun List<String>.getLongestString() { /*...*/}
```

Для использования - обычный импорт:
```
import org.example.declarations.getLongestString

fun main() { 
    val list = listOf("red", "green", "blue") 
    list.getLongestString() 
}
```


[id](001.004.021)


## 022. Пример объявления расширений внутри другого класса. Особенности вызова. К чему есть доступ внутри, как различить при конфликтах.


1. Можно объявить расширение для класса внутри другого класса. Это расширение **доступно только внутри класса**, где объявлено:
```kt
class Host(val name: String) { 
    fun printHost() { .. }
}

class Connection(val host: Host) {
    fun printPort() { .. }
    fun Host.printConnection() { .. }
   
    fun connect() {
        /* .. */
        host.printConnection()  
    }
}

Connection(Host()).printConnection() // ERROR: нельзя вне класса вызывать
```
2. Внутри есть доступ к методам расширяемого и текущего классов напрямую без всяких **this**.
```kt
...
    fun Host.printConnection() {
        printPort() // из текущего класса
        printHost() // из расширяемого класса Host
    }
...
```

При конфликтах сигнатур - **преимущество за методами из расширяемого класса** (функция на нем вызывается). Вызвать метод класса, в котором объявляется, - через **квалифицированный this**:
```kt
...
    fun Host.printConnection() {
        toString() // из класса Host
        this@Connection.toString()
    }
...
```


[id](001.004.022)