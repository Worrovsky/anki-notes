## 001. Что такое **вариантность** (**variance**): инвариантность, ковариантность, контрвариантность. Что с вариантностью универсальных типов в Java. Пример с ошибкой, если бы было иначе.


**Вариантность** определяет как связаны между собой типы с одним базовым типом и разными типовыми аргументами, например `List<String>` и `List<Any>`:
* типы T<А> и Т<В> - **инвариантны**, если между ними нет отношений тип-подтип, при любых отношениях между A и В.
* типы T<А> и Т<В> - **ковариантны**, если Т<А> является подтипом T<В>, когда A - подтип В.
* типы T<А> и Т<В> - **контрвариантны**, если отношение между универсальными противоположно отношению между типовыми аргументами:  Т<А> является подтипом T<В>, когда А - супертип В или наоборот.
 
В Java универсальные типы **инвариантны**, т. е. например `List<String>` не является подтипом `List<Object>`. Пример, если бы не были инвариантны:
 
```java
// Java
List<String> strs = new ArrayList<String>();
List<Object> objs = strs; // это не скомпилируется, но если
objs.add(1);
String s = strs.get(0); // ClassCastException
```
 
Массивы в Java коварианты и поэтому подвержены такой ошибке.


[id](001.006.001)


## 002. Связь понятий **тип** и **класс**. Что такое **подтип**. Инвариантность универсальных классов по типовому параметру.


**Тип** определяет допустимые значения для переменной этого типа. Поэтому один **класс** может создавать несколько типов. Например класс `Any` создает типы `Any` и `Any?`. Особенно это видно с универсальными типами. Класс `List` порождает множество типов `List<Any>`, `List<String>` и т. п.
 
Тип В -  это **подтип** А, если значение типа В можно использовать везде, где ожидается А. Например `Any` подтип `Any?`, `Int` подтип `Number` и т. п.
 
**Супертип** - обратный термин.
 
Универсальные классы в Java **инвариантны по типовым аргументам**. Т. е. для любых А и В, `T<A>` не является ни подтипом, ни супертипом `Т<B>`. Для Kotlin аналогично.


[id](001.006.002)


## 003. **Исходящие** (**out**) и **входящие** (**in**) позиции типового параметра. Правило для использования универсальных типов **по месту объявления** (**Declaration-site variance**).


**Исходящая (out) позиция** - когда параметр типа используется в качестве выходного параметра функции, т. е. функция *производит* это значение (является **Producer**).
 
**Входящая (in) позиция** - когда параметр типа используется как входной параметр функции, т. е. функция *потребляет* это значение (является **Consumer**).
 
```kt
interface Producer<T> {
    fun produce(): T
}
interface Consumer<T> {
    fun consume(t: T)
}
```
 
При создании универсальных типов следует использовать правило:
 
    Producer - out, Consumer - in
 
Например интерфейс `List` объявлен через **out**, т. к. это неизменяемая коллекция и методы только производят новые элементы типа Т, не вставляя (потребляя) их.
```kt
interface List<out E> : Collection<E>
```
 
Аналог для Java:
 
    Producer-Extends, Consumer-Super (PECS)


[id](001.006.003)


## 004. Объявление **ковариантности** для универсальных типов по месту объявления: как, когда разрешено, последствия.  Как такое же в Java.


Если типовой параметр только возвращается из методов объекта универсального типа, такой объект можно сделать **ковариантным** при объявлении (**Declaration-site variance**), используя **out**:
 
```kt
interface Source<out T> {
    fun next(): T
}

fun demo(strs: Source<String>) {
    val objects: Source<Any> = strs // OK, типы коварианты из-за объявления с out
}
```
 
Без указания **out** типы `Source<String>` и `Source<Any` будут **инвариантны**.
 
Если типовой параметр объявлен с **out**, его нельзя использовать во **входящей** (**in**) позиции:
```kt
interface Source<out T> {
    fun consume(t: T) // error
}
```
 
В Java такое нельзя установить при объявлении, пришлось бы при создании конкретного типа через _wildcards_ (правило **PECS**): 
```java
interface Source<T> {
    T nextT();
}
void demo(Source<String> strs) {
    Source<? extends Object> objects = strs;
}
```


[id](001.006.004)


## 005. Объявление **контрвариантности** для универсальных типов по месту объявления: как, когда разрешено, последствия.  Как такое же в Java.


Если типовой параметр используется только для входных аргументов методов объекта универсального типа, такой объект можно сделать **контрвариантным** при объявлении (**Declaration-site variance**), используя **in**:
 
```kt
interface Comparable<in T> {
    operator fun compareTo(other: T): Int
}
 
fun demo(x: Comparable<Number>) {
    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
    // Thus, you can assign x to a variable of type Comparable<Double>
    val y: Comparable<Double> = x // OK!
}
``` 
 
Если типовой параметр объявлен c **in**, его нельзя использовать в **исходящей** позиции: 
```kt
interface Comparable<in T> {
    fun produce(): T // error
}
```
 
В Java такое можно сделать только при использовании универсального класса, не при объявлении, через _wildcards_ (правило **PECS**): 
```java
interface Comparable<T> {
    void compareTo(T other);
}
void demo(Comparable<Number> nums) {
    Comparable<? super Object> objects = nums;
}
```


[id](001.006.005)


## 006. Ключевые слова **out** / **in** в объявлении универсальных типов: последствия.


Ключевое слово **out** у типового параметра означает, что:
* сохраняется отношение подтипа (**ковариантность**)
* типовой параметр `T` может использоваться только в **исходящей** позиции
```kt
interface Produser<out T> {
    fun produce(): T
}
 
fun demo(x: Produser<String>) {
    val y: Produser<Any> = x // OK, ковариантность
}
```
 
Ключевое слово **in** у типового параметра означает, что:
* отношение тип-подтип меняется на противоположное (**контрвариантность**)
* типовой параметр `Т` может использоваться только во **входящей** позиции
```kt
interface Consumer<in T> {
    fun consume(t: T)
}
 
fun demo(x: Consumer<Any>) {
    val y: Consumer<String> = x // OK, контрвариантность
}
```


[id](001.006.006)


## 007. Как определить исходящая или входящая позиция у типового параметра.


Типовой параметр во **входящей позиции**, если он используется в аргументах функции. В **исходящей** - если используется в возвращаемом значении.
 
Особенности для конструкторов:
* если это простой параметр конструктора - не находится ни в какой позиции
* если **val** - тогда в исходящей (в геттере), если **var** - в обоих позициях
 
Для скрытых методов (**private**) - позиция типового параметра не влияет ни на что.
 
Если параметр одновременно в исходящей и входящей позициях, объявлять его **out** или **in** небезопасно и запрещено.


[id](001.006.007)


## 008. Два способа определения вариантности: сравнение, аналоги в Java. Два способа определения вариантности по месту использования. Пример с копированием массивов.


1. Способы определения вариантности:
* **по месту определения** (**declaration-side variance**): при объявлении универсального класса/интерфейса/метода через **out**/**in**
* **по месту использования** (**use-side variance**) - указание возможности использования типов/подтипов при использовании.
 
Первый способ удобнее: один раз объявили - можно использовать везде. Второй - каждый раз при использовании надо указывать.
 
В Java есть только второй способ - **wildcards** `? extends T`, `? super T`.
 
2. Ограничить типы **по месту использования** можно двумя способами:
* ограничить тип по верхней границе
* использовать **проекции типов** (**type projection**)
 
```kt
// здесь можем копировать только Array<Any> - массивы инвариантны
fun copy(from: Array<Any>, to: Array<Any>) { .. }
 
// можно любые через проекцию типа
fun copy(from: Array<out Any>, to: Array<Any>) { ... }
 
// тоже любые, но через отдельный тип с ограничением
fun <T: R, R> copy(from: Array<T>, to: Array<R>) { ... }
```


[id](001.006.008)


## 009. **Проекции типа** (**type projection**): зачем, пример и накладываемые ограничения.


Служат для добавления вариантности (расширения допустимых типов) по месту использования.
 
Например копирование мутабельных списков: сами списки инвариантны, но корректно например в список `Any` скопировать список `String`:
```kt
fun<T> copy(from: MutableList<out T>, to: MytableList<T>) { .. }
 
val strings = mytableListOf("abc")
val list: List<Any> = mutableListOf()
copy(strings, list)
```
 
Аналогично с **in**.
 
Проекции типа накладывают ограничения: нельзя вызывать методы, в которых типовой аргумент находится в противоположной позиции(для **out** разрешено только в исходящей позиции (возвраты из методов), для **in** - только во входящей (только параметры методов).
 
```kt
val list: MutableList<out Number> = mutableListOf()
list.add(42) // ERROR: запрещено использовать out-проекцию
``` 


[id](001.006.009)


## 010. **Проекция со звездочкой** (**star projection**): зачем. Эквивалентные типы.


Означает, что о типе нет информации.
 
Не то же самое, что `Any?`. Например в `MutableList<Any?>` можно добавлять элементы, а в `MutableList<*>` - нет, т. к. неизвестно какие ожидания при извлечении элементов.
 
Эквивалентные типы(то как считает компилятор):
* если класс объявлен как `Foo<out T: TUpper>`, эквивалент `Foo<*>` - `Foo<out TUpper>`. Например эквивалент `List<*>` - `List<out Any?>` (список объявлен как `List<out E>`). Означает что у типа со звездочкой можно только вызывать методы, возвращающие типовой параметр (в *out* позиции)
* если класс объявлен `Foo<in T>`, эквивалент - `Foo<in Nothing>`. Означает, что вызовы, возвращающие типовой параметр запрещены, а принимающие - только с `Nothing`, т. е. ничего нельзя
* если класс объявлен `Foo<T: TUpper>` - эквивалент `Foo<out Upper>` для чтения и `Foo<in Nothing>`
 
Итого: для типов со звездочкой разрещено получать значения универсального типа в переменные типа `Any?` и запрещено вызывать любые методы с входными параметрами универсального типа.


[id](001.006.010)


## 011. Объявление параметризованных типов: классов, интерфейсов, функций. Использование.


У классов и интерфейсов параметр типа расположен **после** имени:
```kt
class Box<T>(t: T) {
    var value = t
}
 
interface Some<T> {
    fun get(): T
}
``` 
 
У функций - **перед**:
```kt
fun <T> getList(item: T): List<T> { .. }
```
 
При использовании нужно указать тип или у переменной, или у параметризированного типа. Обычно компилятор не может вывести.
```kt
val box = Box<Int>(1)
val boxOfString: Box<String> = Box("abc")
val list = getList<Int>(2)
```


[id](001.006.011)


## 012. Как ограничить универсальные типы.  Что значит ограничение по верхней границе. Аналог в Java.  Как ограничить несколькими.


Можно ограничить **по верхней границе**. Запись: `<T: TUpper>`.
 
Ограничение по верхней границе значит, что в качестве типового аргумента использовать можно только указанный тип `TUpper` или его подтипы.
 
```kt
fun <T: Comparable<T>> sort(list: List<T>) { .. }
 
sort(listOf(1, 2, 3)) // OK: Int подтип для Comparable<Int>
sort(HashMap<Int, String>()) // ERROR: HashMap<Int, String> не подтип Comparable
``` 
 
Аналог в Java: `<T extends Comparable>`
 
По умолчанию верхняя граница - **Any?**.
 
Если несколькими ограничить одновременно - через **where**:
```kt
fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>
    where T : CharSequence,
          T : Comparable<T> { .. }
```


[id](001.006.012)


## 013. Как ограничить поддержку null в типовом параметре.


Нужно ограничить тип по верхней границе любым типом, не поддерживающим null. Например `Any`, если больше нет никаких ограничений:
```kt
class Proccessor<T: Any> {
    fun do(value: T) {
        println(value.toString()) // не нужна проверка на null
    }
}
``` 
 
По умолчанию типы ограничиваются сверху `Any?`, поэтому возможны `null`.


[id](001.006.013)


## 014. Что такое стирание типов. Какие последствия для приведения и проверки типов (3 шт).


**Стирание типов** (**type erasure**) - механизм JVM, при котором типовые аргументы универсальных типов не сохраняются во время выполнения. Иначе: экземпляр универсального класса не хранит информацию о типовых аргументах, использованных при создании этого экземпляра.
 
Например `List<Any>` и `List<String>` в рантайме оба имеют тип `List` с неизвестным типом элементов. Про типы известно только компилятору.
 
Следствие 1: невозможно проверить тип с типовыми аргументами. Поэтому такие проверки через **is** запрещены:
```kt
fun foo(list: List<Any>) {
    val b = list is List<String> // ERROR: cannot check erased type
    // val c = list is List // нельзя использовать унив. типы без указания параметра
    val d = list is List<*> // только так
}
``` 
Но если компилятору известны типы, тогда допустимы:
```kt
fun foo(c: Collection<Int>) {
    if (c is List<Int>) { .. } // OK
}
``` 
 
Следствие 2: в операциях приведения типов **as/as?** можно использовать универсальные типы, но такое приведение никак не может проверить тип аргумента. Компилятор всего лишь выдает предупреждение: `unchecked cast`:
```kt
fun foo(c: Collection<Any>) {
    val stringList = c as? List<String> // warning: unchecked cast
    val s = stringList.get(0)
}
foo(listOf(1, 2)) // ClassCastException
```

Следствие 3: в функции с универсальным типом нельзя ссылаться на типовой аргумент:
```kt
fun <T> isA (value: Any) {
    value is T // ERROR: cannot check for instance of erased type
}
```


[id](001.006.014)


## 015. Последствия стирания типов для функций универсальных типов. Что такое **овеществление типовых параметров** inline функций. Синтаксис. Как это работает.


Т. к. во время выполнения нет информации о типовом аргументе, в функциях универсальных типов запрещено использовать типовые параметры (например для проверки типа):
```kt
fun <T> isA(value: Any) = value is T // ERROR
```

Для inline-функций можно ссылаться на типовые параметры (овеществление), если объявить с **reified**:
```kt
inline fun <reified T> isA(value: Any) = value is T // OK
```

Т. к. inline-функции встраиваются в байт-код напрямую в месте вызова, в байт-код встраивается и конкретный тип вместо типового аргумента.


[id](001.006.015)


## 016. Примеры овеществления типов inline-функций: **filterIsInstance()**.


Функция фильтрует элементы коллекции по заданному типу:
```kt
inline fun <reified T> 
        Iterable<*>.filterIsInstance(): List<T> {
    val dest = mutableListOf<T>()
    for (element in this) {
        if (element is T) dest.add(element)
    }
    return dest
}
```


[id](001.006.016)


## 017. Для чего (где) можно использовать reified-параметры inline-функций. Где нельзя использовать.


Овеществленные типы можно использовать:
* в операциях проверки и приведения типов **is**, **as**
* как типовой аргумент для вызова других типов
* для получения соответствующего класса (`::class.java`)

Вот пример создания экземпляра по классу:
```kt
inline fun <reified T> loadService() {
    return ServiceLoader.load(T::class.java)
}
```

Нельзя:
* создавать новые экземпляры класса через типовой параметр
* вызывать методы объекта-компаньона для класса в типовом параметре
* использовать неовеществленный типовой параметр для вызова функции с овеществленным


[id](001.006.017)