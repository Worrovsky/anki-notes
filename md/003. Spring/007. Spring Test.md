## 001. Суть аннотации @SpringBootTest. Особенность тестирования SpringMVC части.


Создание контекста и инициализация бинов всего приложения. Поэтому тяжелая операция. Это интеграционные тесты, не следует использовать для юнит-тестов (моки лучше).

Так можно проверить работоспособность конфигурации:
```kt
@SpringBootTest
internal class DemoApplicationTest {
    @Test
    fun `context loaded`() {
        // здесь ничего не надо
    }
}
```

По умолчанию для MVC блока (контейнер сервлетов) создаются моки. За это отвечает перечисление **WebEnvironment**:
* **WebEnvironment.NONE** - моки для бинов MVC. Используется, если тестируется не web-часть приложения
* **WebEnvironment.RANDOM_PORT** - стартует контейнер сервлетов на случайном порту. Обычно это используют.
* **WebEnvironment.DEFINED_PORT** - на конкретном порту (8080 по умолчанию), можно указать каком. Редко используется (конфликты портов)
```kt
@SpringBootTest(
    webEnvironment = WebEnvironment.RANDOM_PORT)
class AppTest {
    @LocalServerPort
    var port = 0;
    
    @Test
    fun `view port`() {
        println(port)
    }
}
```


[id](003.007.001)


## 002. MockMvc: для чего используется, как создать.


Класс **MockMVC** используется для эмулирования сервера. Все запросы в тесте направляет к контроллерам как реальный сервер, но нет расходов на запуск сервера.

Контоллеры можно тестировать юнит-тестами, но тогда мимо проходят вопросы валидации, преобразования, связывания данных и т. п. **MockMvc** позволяет это проверять.

Настройка:
```kt
@SpringBootTest
// включаем авто-настройку
@AutoConfigureMockMvc 
class AppTest(
    // внедряем бин через конструктор
    @Autowired val mockMvc: MockMvc 
    ) {
    
    @Test
    fun 'get request should return 200'() {
        mockMvc.get("/users")
            .andExpect { stat}
    }
```


[id](003.007.002)


## 003. Тонкая настойка MockMvc для тестирования отдельных контроллеров.


Использование **@SpringBootTest** + **@AutoConfigureMockMvc** создает полный контекст приложения со всеми бинами.

Через **@WebMvcTest** можно создавать только бины, относящиеся к web-части (контроллеры в т. ч.). Остальные зависимости, если нужны контроллерам, нужно явно создавать (например через **@MockBean** (Mockito) или **@MockkBean** (Mockk))
```kt
@WebMvcTest
internal class UserControllerTest(
    @Autowired val mockMvc: MockMvc) {

    @MockBean
    lateinit var userService: UserService

    @Test
    fun `should return ok`() {
        mockMvc.get("/api/users")
            .andExpect { status { isOk() } }
    }
}
```
Можно не создавать все контроллеры, а только нужный:
```kt
@WebMvcTest(UserController::class)
internal class UserControllerTest { ... }
```


[id](003.007.003)


## 004. Примеры использования MockMvc: выполнение запроса и проверка статуса, печать запроса и ответа, проверка JSON-результата.


1. Выполнение и настройка запроса (котлиновский DSL):
```kt
mockMvc.get("/api/users") {
    // здесь доступ к MockHttpServletRequestDsl
    // доступ к реквизитам запроса
    contentType = MediaType.APPLICATION_JSON
}  // теперь есть доступ к ответу
    .andExpect {
        status { isOk() }
    }
```
можно другие методы `put()`, `delete()` и прочие, или общий `request()`

2. Печать запроса и ответа:
```kt
mockMvc.get("/api/users") 
    .andDo { print() }
```
3. Проверка JSON-результата запроса:
```kt
mockMvc.get("/api/users") 
    .andExpect {
        status { isOk() }
    }
    .andExpect {
        content { contentType(MediaType.APPLICATION_JSON) }
    }
    .andExpect {
        jsonPath("$") { isArray() }
        jsonPath("$[0].name") { value("Alice") }
    }
```


[id](003.007.004)
