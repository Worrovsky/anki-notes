## 001. Что такое Dependency Injection? Типы.


**DI** - техника создания ПО, когда объекты не создают свои зависимости внутри себя. Вместо этого они объявляют зависимости, в которых нуждаются, и внешний объект / фрейморк предоставляет им эти зависимости

Примеры:
* **(без DI)** внутри объекта переменная типа класса и создание экземпляра через `new()`.
* **(ручной DI)** переменная имеет тип интерфейса. Присваивание - через конструктор. Зависимость внедряется извне при создании объекта.

Типы:
* внедрение через конструктор
* внедрение через сеттер
* внедрение через интерфейс (клиент реализует интерфейс, который определяет как будет внедрятся зависимость (например через метод-сеттер))


[id](003.002.001)


## 002. Что такое интерфейсы, преимущество их использования. Почему интерфейсы рекомендуются для Spring бинов.


(ООП) **Интерфейc** - описание действий, которые может выполнять объект. Способ заставить объект, реализующий интерфейс выполнять действия.

(Java) **Интерфейс** - ссылочный тип, содержащий коллекцию абстрактных методов. Класс, реализующий интерфейс, обязан реализовать эти методы или объявить их абстрактными.

Преимущества:

* разделяют контракт и его реализацию
* позволяют определить контракт между объектами
* увеличивают взаимозаменяемость объектов
* упрощают тестирование

Преимущества интерфейсов для Spring:

* позволяют использовать JDK Dynamic Proxy
* скрывают реализации
    - интерфейс публичный, реализации - в пределах пакета
    - так вынуждаем использовать контракты, а не реализации
* позволяют легко менять бины (квалификаторы и др.)


[id](003.002.002)


## 003. Что такое Application Context? Задачи.


Это центральная часть Spring приложения. Это интерфейс. Наследует несколько других интерфейсов.

Отвечает за:

* инициализацию и конфигурацию бинов
* управление жизненным циклом бинов
* загрузку ресурсов (интерфейс `ResourceLoader`)
* отправку событий зарегистрированным обработчикам событий
* это фабрика бинов (интерфейс `BeanFactory`)
* доступ к `Environment` для получения свойств

Реализации **ApplicationContext**:

* **AnnotationConfigApplicationContext** - конфигурация на аннотациях
* **AnnotationConfigWebApplicationContext** - то же, но веб-приложения, для контейнера сервлетов
* **ClassPathXmlApplicationContext** - xml-конфигурация, файлы конфигурации в classpath
* **FileSystemXmlApplicationContext** - то же, но файлы конфигурации в файловой системе


[id](003.002.003)


## 004. Общий алгоритм создания AnnotationConfigApplicationContext и получения бинов


Общий алгоритм:
* создать контекст
* определить бины (несколько способов)
* создать и загрузить бины в контекст (обновить конфигурацию)
* получить бин

Необходимые  зависимости: **spring-core** и **spring-context**.

Например есть бин:
```kt
package bean

interface Printable {
    fun print()
}

@Component
class SimpleBean : Printable {
    override fun print() {
        println("Hello, I am SimpleBean")
    }
}
```
Создаем контекст:
```kt
// 1. создаем контекст
val context = AnnotationConfigApplicationContext()
// 2. описываем размещение бинов (например через пакет)
context.scan("com.example.bean")
// 3. загружаем бины
context.refresh()
// 4. получаем бин
val printableBean = context.getBean<Printable>()
```


[id](003.002.004)


## 005. Способы определения конфигурации бинов при создании AnnotationConfigApplicationContext


Две группы методов:
* сканирование пакетов и поиск бинов (метод **scan()**)
    - классы должны быть с аннотацией **@Component** и производными
* регистрация бинов через классы (метод **register()**)
    - аннотации не нужны

Далее обновляем контекст и можем получать бины.

1. **Сканирование по пакетам**:
```kt
val ctx = AnnotationConfigApplicationContext()
// в пакете должны быть классы с аннотациями
ctx.scan("com/example/bean")
ctx.refresh()
val bean = ctx.getBean<Printable>()
bean.print()
```
2. **Регистрация бинов через классы**:
```kt
val ctx = AnnotationConfigApplicationContext()
// класс SimpleBean может быть без аннотаций
ctx.register(SimpleBean::class.java)
ctx.refresh()
val bean = ctx.getBean<Printable>()
bean.print()
```


[id](003.002.005)


## 006. Способы настройки контекста через конструктор


В зависимости от параметров конструктора, внутри вызываются **scan()/refresh()** или **register()/refresh()**.

Параметры конструкторов:

1. **Пакеты**, содержащие бины. Внутри конструктора вызываются методы **scan()** и **refresh()**. Бины должны быть с аннотацией **@Component**:
```kt
val ctx = AnnotationConfigApplicationContext("com.example.bean")
val printableBean = ctx.getBean<Printable>()
```
2. **Конфигурационный класс с `@ComponentScan`**. Тем самым определяем пакеты для сканирования. Бины должны быть с аннотацией **@Component**.
```kt
// по умолчанию сканируются 
// пакеты, где класс расположен
@ComponentScan
class BeanPackageConfig {
}
```
```kt
val ctx = AnnotationConfigApplicationContext(BeanPackageConfig::class.java)
val bean = ctx.getBean<Printable>()
```
3. **Перечень классов-бинов**:
```kt
// аннотации над SimpleBean не нужны
val ctx = AnnotationConfigApplicationContext(SimpleBean::class.java)
val bean = ctx.getBean<Printable>()
```
4. **Перечень классов, создающих бины**:
```kt
class BeanConfig {
    @Bean
    fun getBean(): Printable = SimpleBean()
}
...
val ctx = AnnotationConfigApplicationContext(BeanConfig::class.java)
val bean = ctx.getBean<Printable>()
```


[id](003.002.006)


## 007. Контейнер, его жизненный цикл. BeanFactoryPostProcessor и BeanPostProcessor.


Контейнер - окружение, предоставляющее средства для управления бинами. Управляет жизненным циклом бинов, дает доступ к **ApplicationContext**.

Жизненный цикл:
1. Запуск приложения
2. Создание контейнера
3. Контейнер читает конфигурацию
4. Создание **описаний** (**definition**) бинов
5. Описания бинов обрабатываются **BeanFactoryPostProcessor**
6. Создание экземпляров бинов
7. Настройка бинов: свойства, внедрение зависимостей
8. Вызов реализаций **BeanPostProcessor** (обрабатывает экземпляры)
9. Приложение запущено
10. Завершение работы приложения
11. Закрытие контекста
12. Вызов методов завершения жизненного цикла бинов

**BeanFactoryPostProcessor** vs **BeanPostProcessor**:
* **BFPP** вызывается после того как прочитаны все определения бинов, до создания экземпляров, работает **с описаниями бинов**
* **BPP** работает **с экземплярами бинов**, вызывается после создания экземпляра:
    - в начале работы контейнера 
    - в процессе работы приложения, если загрузка бина - по требованию


[id](003.002.007)


## 008. Способы управления жизненным циклом бинов. Порядок вызова методов


Можно различать по месту описания логики:

1. **Внутри бина**:
* Методы с JSR-350 аннотациями **@PostConstruct** и **@PreDestroy** (нужны доп. зависимости `javax.annotation`)
* Реализация интерфейсов **InitializingBean** и **DisposableBean**

2. **Вне бина, но используются методы бина**:

При описании бина через аннотацию **@Bean(initMethod=.., destroyMethod=..)**

3. Полностью **независимо от бина**:

Реализация интерфейса **BeanPostProcessor**
* создать бин такого типа
* будут вызваны методы интерфейса для каждого экземпляра бина
* в параметрах есть доступ к имени бина и объекту

Порядок вызовов **при создании** бина:
* создаются бины
* настраиваются свойства, внедряются зависимости
* вызывается **BPP::postProcessBeforeInitialization()**
* вызывается метод с **@PostConstruct**
* вызывается метод **InitializingBean::afterPropertiesSet()**
* вызывается метод из **@Bean(initMethod=..)**
* вызывается **BPP::postProcessAfterInitialization()**

Порядок вызовов **при уничтожении** бина:
* контекст уничтожается, и вместе с ним уничтожаются бины
* вызывается метод с **@PreDestroy**
* вызывается метод **DisposableBean::destroy()**
* вызывается метод из **@Bean(destroyMethod=...)**


[id](003.002.008)


## 009. Примеры способов управления жизненным циклом бинов.


1. **@PostConstruct/@PreDestroy**:
```kt
class SimpleBean {
    @PostConstruct
    fun init() {
        println("2.1 Post construct done!")
    }
    @PreDestroy
    fun preDestroy() {
        println("3.1 Pre destroy done!")
    }
}
```
2. **InitializingBean/DisposableBean**:
```kt
class SimpleBean: InitializingBean, DisposableBean {
    override fun afterPropertiesSet() {
        println("2.2 afterPropertiesSet")
    }
    override fun destroy() {
        println("3.2 destroy done!")
    }
}
```
3. **@Bean(initMethod=.., destroyMethod=..)**:
```kt
@Component
class SimpleBean {
    fun initMethod() {
        println("init method")
    }
    fun destroyMethod() {
        println("destroy method")
    }
}

class BeanConfig {
    @Bean(initMethod = "initMethod", destroyMethod = "destroyMethod")
    fun getBean(): Printable = SimpleBean()
}

fun main(args: Array<String>) {
    val ctx = AnnotationConfigApplicationContext(BeanConfig::class.java)
    ctx.close()
}
```
4. **BeanPostProcessor**:
```kt
@Component
class BeanPostProcessorImpl: BeanPostProcessor {
    override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
        println("BPP:ppBeforeI $beanName")
        return bean
    }
    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        println("BPP:ppAfterI $beanName")
        return bean
    }
}
```


[id](003.002.009)


## 010. Способы закрытия контекста.


Если не закрыть правильно, не будут вызваны методы жизненного цикла на уничтожение бинов (@`PreDestroy` и т. п.)

* не веб-приложение:
    - (рекомендуется) установить хук **ConfigurableApplicationContext::registerShutdownHook**
    - вызвать **ConfigurableApplicationContext::close**
* веб-приложение:
    - **ContextLoaderListener** автоматически закроет контекст, когда веб-контейнер остановит приложение
* SpringBoot:
    - **ApplicationContext** будет автоматически остановлен
    - Shutdown хук регистрируется автоматически
    - **ContextLoaderListener** также автоматически закрывает контекст в веб-приложении 

**Кратко**:
* веб, SpringBoot - закроют автоматом
* в остальных - `ctx.registerShutdownHook()` 


[id](003.002.010)


## 011. Виды DI: с помощью программной конфигурации, с помощью аннотаций.


1. **Программная конфигурация**: Все бины объявляются в классе-конфигурации (с аннотацией **@Configuration**) c помощью аннотации **@Bean** над методами. Для внедрения зависимостей используется **@Autowired**
```kt
@Configuration
class AppConfig {
    @Bean
    fun getBean(): Printable = SimpleBean()
}
```
Собственно классы бинов не имеют никаких аннотаций.

На основании конфигурации создается контекст:
```kt
val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
```
2. **Через аннотации**: Создаем классы-бины с аннотацией **@Component**. Внутри можно внедрять зависимости через **@Autowired**.
```kt
@Component
class SimpleBean {
    ...
}
```
Далее любым способом настраиваем сканирование, например через класс с **@ComponentScan** и создаем контекст.
```kt
@ComponentScan
class AppPackageConfig {
    // пусто
}
fun main() {
    val ctx = AnnotationConfigApplicationContext(AppPackageConfig::class.java)
}
```


[id](003.002.011)


## 012.  Варианты сканирования компонентов (@ComponentScan)


1. Можно просто указать аннотацию **@ComponentScan** без уточнений, тогда целью сканирования будет пакет, где расположен класс-конфигурация и вложенные пакеты:
```java
@ComponentScan
public class ApplicationConfiguration {...}
```
2. Можно указать конкретный пакет для сканирования:
```java
@ComponentScan(basePackage="a.b.x")
public class ApplicationConfiguration {...}
```
3. Класс, по пакету которого будет проходить сканирование:
```java
@ComponentScan(basePackageClasses = SomeBean.class)
public class ApplicationConfiguration {...}
```
4. Можно еще дополнительно фильтры:
```kt
@ComponentScan(
   basePackages = "a.b.c",
   includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean.*"),
   excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean1.*")
```


[id](003.002.012)


## 013. Что такое стереотипные аннотации. Отличие от @Bean. Что такое мета-аннотации.


**Стереотипные аннотации** - аннотации, применяемые к классу, для описания его роли. Spring создает бины для классов, помеченных такими аннотациями. 

Сравнение с **@Bean**: **@Bean** - аннотация для метода, стереотипные аннотации - для типов (классов)

Примеры:

* **@Component** - компонент общего назначения
* **@Service** - класс, содержащий бизнес-логику
* **@Repository** - класс, использующийся для доступа к БД
* **@Controller** - класс контроллер, обычно в веб-приложении

С точки зрения контейнера все эти виды равнозначны, и только разработчик определяет их смысл.

**Мета-аннотации** - аннотации, состоящие из других аннотаций. Например - **@RestController** = **@Controller** + **@ResponseBody**.


[id](003.002.013)


## 014. Область видимости бинов. Настройка.


Варианты области видимости (scope):
* Singleton - один бин на контейнер. По умолчанию.
* Prototype - каждый раз, когда требуется бин - создается новый экземпляр.
* Request - новый экземпляр на каждый запрос.
* Session - новый экземпляр на сессию.
* Application - один экземпляр на ServletContext (в приложении может быть несколько контекстов).
* WebSocket - один экземпляр на каждый сокет.

Задается через аннотацию **@Scope**:
* рядом с **@Component** над классом
* рядом с **@Bean** над методом.
```kt
@Component
//@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
class SimpleBean : Printable { ... }
```
**!! не путать:** нет смысла ставить над классом бина, если контекст создается через класс-конфигурацию (`@Configuration`). В этом случае ставить нужно над методом класса-конфигурации:
```java
//@Scope("prototype") - не имеет смысла
public class Bean1 {...}

@Configuration
public class Config {
    @Bean
    @Scope("prototype") // здесь можно
    public Bean1 bean1() {return new Bean1();}
}
```


[id](003.002.014)


## 015. Ленивая/горячая (lazy/eagerly) загрузка бинов.


Зависит от области видимости:
* **Singleton** по умолчанию загружаются всегда (**eagerly**)
* **Prototype** - ленивая загрузка (по требованию) (**lazy**)
    - исключение: если prototype-бин входит в состав синлтона, тогда он также загружается всегда

Изменение варианта загрузки:

* через **@ComponentScan(lazyInit=true/false)**
    - по умолчанию - `false`, **Singleton** - eagerly, **Prototype** - lazy
    - `true` - все бины - lazy, даже сингтоны
* через аннотацию **@Lazy(true/false)**
    - по умолчанию включает lazy-режим
    - **@Lazy(false)** - eagerly
    - где можно применять:
        + на **@Component**: этот бин будет загружаться, как указывает **@Lazy**
        + на **@Configuration**: все бины этой конфигурации загружаются, как указывает **@Lazy**
        + на метод с **@Bean**: этот бин загружается, как указывает **@Lazy**


[id](003.002.015)


## 016. @Autowired: порядок разрешения зависимостей, необязательность


**@Autowired** - аннотация, которая обрабатывается **AutowiredAnnotationBeanPostProcessor**. Позволяет внедрять зависимости в бины.

Может размещаться над:
* конструктором
* полем
* сеттером
* конфигурационным методом

Порядок разрешения зависимости:
1. Проверяется соответствие по типу, если найден ровно один бин - поиск завершается.
2. Если найдено несколько бинов по типу, проверяется есть ли аннотация **@Primary**. Если есть такой бин - завершается
3. Проверяется, есть ли **@Qualifier** для поля, ищется по нему
4. Если всё еще не найден, ищется по имени бина
5. Если не найден - исключение (**NoSuchBeanDefinitonException**, **NoUniqueBeanDefinitionException**)

По умолчанию зависимость обязательна. Необязательность можно указать:
* через тип **Optional**
* аннотацией **@Nullable** (из Spring)
* **@Autowired(required = false)**
```kt
...
@Autowired
@Nullable
lateinit var dependency: Service

fun out() {
    if (::dependency.isInitialized) {
        dependency.doWork()
}
```


[id](003.002.016)


## 017. Способы внедрения зависимостей через @Autowired


1. Внедрение **через поле**
```kt
@Autowired
lateinit var dependency: SomeService
```
Особенности:
* Модификатор доступа - любой.
* Внедрение - после создания экземпляра, но до вызова любого инициализационного метода.
* По умолчанию - обязателен, но можно любым способом необязательность указать.

2. Внедрение **через конструктор**
```kt
@Component
class YourBean @Autowired constructor(
    private val solrClient: SolrClient
) {
  // code
}
```
Особенности:
* Модификатор доступа - любой
* Если есть единственный конструктор - можно не указывать `@Autowired`, Spring сам его будет использовать и внедрит зависимости.
* Если несколько конструкторов - обязаны пометить один, если нет - исключение **NoSuchMethodExeption**.
* По умолчанию все параметры обязательны, но можно любым способом параметр необязательным указать. 

3. Внедрение **через метод**

```kt
lateinit var dependency: Service

@Autowired
fun setDep(dep: Service) {
    dependency = dep
}
```
Особенности:
* Модификатор доступа - любой.
* Может быть несколько параметров. Если не сможет определить бин - исключения `NoSuchBeanDefinitonException`, `NoUniqueBeanDefinitionException`
* Если указать `@Autowired(required = false`) над методом, метод будет вызван только если будут разрешены все параметры.
* Можно сделать необязательными часть параметров.


[id](003.002.017)


## 018. Аннотация @Qualifier и ее применение вместе с @Autowired


**@Qualifier** дает дополнительный контроль в определении какой бин внедрять, когда по типу соответствует несколько. Решает проблему **NoUniqueBeanDefinitionException**

Если внедрение без **@Qualifier** основано на типах, внедрение c помощью **@Qualifier** основано на именах бинов.

Имена бинов:

* по умолчанию по имена класса (**со строчной начинаются**)
* или метода, если бин вводится через **@Bean**
* можно свое указать в аннотациях **@Component("...")** и производных

Разные варианты использования:

* Над местом внедрения с именем бина в качестве значения 
    - используется имя бина
* Над местом внедрения и определением бина
    - задается псевдоним над определением бина и он же используется при внедрении
* Кастомные аннотации
```kt
@Component
class PrintServiceImpl(
    @Qualifier("simpleBean") private val printable: Printable
    ) : PrintService {
    
    override fun print() {
        printable.out()
    }
}

@Component
class SimpleBean {...} 
```
**Подробнее про кастомную аннотацию:**

Создаем свою аннотацию, наследуемся от **@Qualifier**

Внутри создаем значение (можно enum создать для этого или просто строковое):
```java
    @Qualifier
    @Target({ElementType.FIELD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface ReportType {
        ReportTypeMode value();
        enum ReportTypeMode {
            TYPE_1,
            TYPE_2
        }
    }
```
Теперь эту аннотацию ставим в двух местах: над определением бина и в месте внедрения с одинаковыми значениями


[id](003.002.018)


## 019. Proxy-объекты


**Proxy** - это объект, добавляющий дополнительную логику для проксируемого объекта, без модификации этого объекта. **Proxy** имеет те же публичные методы, что и проксируемый объект и должен быть по возможности неотличим от него.

Обычно **Proxy** добавляет дополнительную функциональность (логгирование, Security и т. п.) до и после методов проксируемого объекта.

Spring применяет два типа:

* **JDK Dynamic Proxy** - на основе интерфейсов
    - можно проксировать только объекты, реализующие интерфейсы
    - только методы интерфейса проксируются
    - не поддерживается **self-invocation** (вызов метода проксируемого объекта внутри другого метода проксируемого объекта)
* **CGLIB Proxy** - на основе наследования
    - не поддерживаются финальные классы
    - не поддерживаются финальные методы
    - также не поддерживает **self-invocation**

Преимущества **Proxy**:

* возможность изменить поведение объекта без изменения исходного кода
* разделение концептуальной логики (логгирование, транзакционность и т. п.)

Недостатки **Proxy**:

* трудности при отладке
* недоступность проверяемых исключений, можно добавлять только непроверяемые (сигнатура метода задана уже)
* могут быть проблемы с производительностью, если методы до и после обращаются к сети, дискам и т. п.
* неожиданное нарушение работы оператора `==`(прокси и проксируемый объект - разные) 


[id](003.002.019)


## 020. Способы конфигурирования Spring-приложения: преимущества и недостатки


Способы задания конфигураций:

* **Java Config**: класс с `@Configuration` и бинами внутри через `@Bean`
* **Annotation Based Config** - `@ComponentScan` + `@Component`
* **Xml Config**

Преимущества **Java Config** vs **XML Config**:

* Проверка типов бинов и полей для внедрения на этапе компиляции
    - вся конфигурация - обычный код, компилятор может видеть ошибки
    - xml же - обычный файл, компилятор никак не проверит (только если IDE поможет)
* Рефакторинг работает из коробки
    - те же причины

Преимущества **Java Config** vs **Annotation Based Config**:

* Разделение концепций конфигурация и реализация бинов:
    - бины - обычные классы, никак не отмеченные
    - только в отдельном классе с `@Configuration` собирается конфигурация
* **Tecnology agnostic** - бины ничего не знают о наличии IoC/DI
* Бинами можно делать объекты сторонних библиотек, к чьему коду нет доступа
* Конфигурация более централизована:
    - расположена в одном месте, легко читать

Недостатки **Java Config**:

* Конфигурационные классы не могут быть финальными и их методы тоже
    - Spring проксирует, чтобы контролировать процесс создания бинов (не вызывать дважды для singleton, например)
* Централизация может мешать в больших проектах 


[id](003.002.020)


## 021. Аннотация @Bean


Аннотация **@Bean** используется в классе **@Configuration** для информирования Spring, что объект, возвращаемый методом с аннотацией **@Bean**, является бином.

Возможности:

* можно указать **initMethod**: будет вызван после вызова конструктора и внедрения зависимостей
    - `@Bean(initMethod = "...")`
* можно указать **destroyMethod**
    - `@Bean(destroyMethod = "...")` 
    - не забыть закрыть контекст
* можно указать имя для бина
    - по умолчанию имя бина - имя метода
* можно указать псевдонимы (все, что кроме первого имени)
    - `@Bean(name = {"name", "alias1", "alias2"})`
* можно указать, является бин кандидатом для внедрения
    - `@Bean(autowiredCandidate = false)`
    - по умолчанию - является
```kt
@Configuration
class AppConfig {
    @Bean(name = ["bean1", "bean2"])
    fun getBean(): SimpleBean {
        return SimpleBean()
    }
}
```


[id](003.002.021)


## 022. Конфигурация профилей: способы указания для бинов, способы активации


* Указать для бинов, к каким профилям они относятся.
* Указать какие профили активны.

**Способы указания профиля**:
* Использовать **@Profile** на уровне **@Component**, тогда этот бин будет частью профиля
* Использовать **@Profile** на уровне **@Configuration**, тогда все бины этой конфигурации будут относиться к этому профилю
* Использовать **@Profile** на уровне метода с **@Bean**, тогда бин, возвращаемый этим методом, будет частью профиля
* Создать собственную аннотацию на основе **@Profile**, и размещать ее как в первых 3-х примерах
    - просто создаем свою аннотацию
    - над ней помещаем аннотацию `@Profile("someProfile")`

Если для бина не задан профиль, подразумевается, что он относится ко всем профилям.

**Способы активации профиля**
* программно через интерфейс **ConfigurableEnvironment**
    - `ctx.getEnvironment().setActiveProfiles("sql");`
* через использование свойства **spring.profiles.active**  
    - например через агрумент CLI `java -jar ... -Dspring.profiles.active=dev` 
* при тестировании JUnit `@ActiveProfiles`
* SpringBoot: программно через **SpringApplicationBuilder**
    - вместо `SpringApplication.run(App.class);`
    - `new SpringApplicationBuilder(App.class).profiles("emailProfile").run(args);`
* SpringBoot: через свойство **spring.profiles.active** например в файле `application.properties`    

**Примеры использования**:
* изменение поведения в различном окружении: prod / dev / и т. п.
* изменение поведения для разных заказчиков
* изменение поведения для тестирования
* добавление в систему дополнительных возможностей: отладка, мониторинг

**Варианты @Profile**:
* один профиль `@Profile("prod")`
* не для профиля `@Profile("!prod")`
* несколько `@Profile({"prod", "dev"})`


[id](003.002.022)


## 023. Значение аннотации @Value. К чему можно применить. Откуда можно получать значения


Позволяет внедрить значение в:
* поле бина
* параметр конструктора
* отдельный параметр метода
* все параметры метода (если установлен над методом)
* аннотации

Внутри аннотации можно указывать:
* простое значение (литерал)
* свойства (разные источники: файлы, переменные окружения и т. п.)
* выражение SpEL `@Value("#{500 * 2}")`
* значения полей других бинов `@Value("#{someBean.someField}")`

Пример:
```kt
@Value("John")
val name: String = ""
@Value("\\${goodbye}") // задано в файле application.properties
val bye: String = ""

override fun run(vararg args: String?) {
    println("Hello, $name!")
    println(bye)
}
```
Значения, начинающиеся с **\$** - свойства, с **#** - выражения SpEL


[id](003.002.023)


## 024. Что такое Environment. Для чего используется. Как получить доступ. Источники свойств.


**Environment** - это спринговый интерфейс `org.springframework.core.env.Environment`.

Основные задачи: 
* работа с профилями (какие активны сейчас, какие активны по умолчанию, переключение профиля)
* работа со свойствами из разных источников (системные переменные, файлы свойств и много другого)

Получить доступ: 

1) через `@Autowired` (предпочтительнее конструктор)
```kt
@Autowired
lateinit var env: Environment
```

2) из контекста (например **ApplicationContext**) через метод `getEnvironment()`

Пример получения свойства:
```kt
val prop = env.getProperty("foo")
```

Источники свойств зависят от типа приложения:
* **автономное** (standalone) приложение
    - файлы свойств
    - системные свойства JVM (system property JVM)
    - системные переменные окружения (system environment variables)
* **веб-приложение** добавляются
    - JNDI
    - ServletConfig параметры
    - ServletContext параметры
* **Spring Boot** еще кучу разных


[id](003.002.024)


## 025. Разница между системными свойствами JVM и переменными окружения. Как установить. Отличие в работе со свойствами через Environment и System.getProperty() / setProperty()


* Установка:
    - свойства: при запуске JVM процесса или в процессе работы
    - переменные: вне процесса, до запуска
* Доступ:
    - свойства: только тому процессу, в котором установлены
    - переменные: любому процессу в ОС
    
Установка свойств:

* при запуске из командной строки `java ... -Dfoo=bar`
* в процессе работы `System.setProperty("foo", "bar")`

Получение:

* свойства: `System.getProperty()`
* переменные: `System.getenv()`

Спринговый **Environment** унифицирует доступ к свойствам и переменным через **get...** + добавляет новые источники свойств.


[id](003.002.025)