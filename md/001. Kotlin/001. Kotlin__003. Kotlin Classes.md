## 001. Структура объявления класса.


Ключевое слово **class** + имя класса + заголовок класса (опц.) + тело класса (опц.)

Пример пустой класс:
```kt
class Person
```
**Заголовок класса** определяет типы параметров, первичный конструктор:
```kt
class Person constructor(firstName: String) { ... }
```


[id](001.003.001)


## 002. Виды конструкторов классов. Полный синтаксис **основного** (**primary**) конструктора. Когда можно опускать ключевое слово `constructor` Упрощенный синтаксис для установки и инициализации свойств. Значения по умолчанию для параметров конструктора Конструкторы по умолчанию.


У класса может быть **основной** (**primary**) конструктор и несколько **вторичных** (**secondary**).  
 
**Основной** конструктор: 
* объявляется вне тела класса
* ключевое слово `constructor` после имени класса и перечисление переменных внутри круглых скобок
* кода содержать не может, поэтому нужен блок инициализации
```kt
class User constructor(_name: String) {
    val name: String
    init {
        name = _name
    }
}
```
Ключевое слово **constructor** может опускаться, если у конструктора нет аннотаций или модификаторов видимости: 
```kt 
class User constructor(name: String) { ... } 
// или то же самое: 
class User (name: String) { ... } 
``` 
Но
```kt 
class User public constructor(name: String) { ... } 
```
Если параметр конструктора используется для инициализации свойства класса, синтаксис можно упростить, добавив `val` к параметру и убрав объявление свойства:
```kt
class User(_name: String) {
    val name = _name
}
// или еще упрощая
class User(val name: String)
```
Параметры конструктора могут иметь значения по умолчанию:
```kt
class User(val name: String = "")
```

Если конструктор явно не объявлен, будет создан конструктор по умолчанию с пустыми параметрами.


[id](001.003.002)


## 003. Что такое блоки инициализации класса. Порядок выполнения


Блоки кода внутри тела класса с ключевым словом **init**
 
При создании экземпляра выполняются вместе с инициализацией свойств, в том порядке как заданы: 
```kt
class InitOrder(name: String) {
   val firstProperty = "1. $name".also(::println)
   init {
         println("2. First init block")
   }
   init {
       println("3. Second init block class " + name)
   }
}
```  
Внутри блоков инициализации есть доступ к  параметрам, определеным в заголовке класса


[id](001.003.003)


## 004. Как объявляются **вторичные** конструкторы класса. Что если уже есть **первичный** Порядок выполнения: блоки инициализации vs вторичный конструктор.


Внутри тела класса ключевым словом **constructor**:
```kt
class Pet {
    constructor(owner: Person) {
        owner.pets.add(this)
    }
}
```
Если уже есть **первичный** конструктор, **вторичный** должен его вызывать явно или неявно через другой вторичный конструктор с помощью ключевого слова `this`:
```kt
class Person (name: String) {
    val age: Int
    constructor(name: String, age: Int) : this(name) {
       this.age = age
    }
}
```
Блоки инициализации всегда выполняются перед кодом вторичного конструктора, даже если первичный конструктор не объявлен явно.


[id](001.003.004)


## 005. Как запретить инициализировать класс


Создать пустой приватный конструктор
```kt
class DontCreateMe private constructor() { .. }
```


[id](001.003.005)


## 006. Как инициализировать экземпляр класса


Просто вызвать конструктор как функцию. Ключевого слова `new` нет:
```kt
var invoice = Invoice()
```


[id](001.003.006)


## 007. Как объявить абстрактный класс.  Как унаследовать абстрактный класс. Нужно ли ключевое слово **open**. Можно ли переопределить член неабстрактного класса и сделать его абстрактным.


Объявление через ключевое слово `abstract`:
```kt
abstract class Polygon {
    abstract fun draw()
}
```
Ключевое слово `open` не нужно, можно наследовать сразу:
```kt
class Circle: Polygon() {
    override fun draw() { /* реализация */ }
}
```
Можно наследовать неабстрактные классы и делать их абстрактными:
```kt
open class Polygon {
    open fun draw() { /* реализация */ }
}
abstract class WildShape: Polygon() {
    abstract override fun draw()
}
```


[id](001.003.007)


## 008. Общий класс для всех других классов. Его методы.


Класс `Any` неявно наследуют любые классы.

Имеет три метода:
* `hash()`
* `equals()`
* `toString()`


[id](001.003.008)


## 009. Как унаследовать класс. Что, если у наследника нет основного конструктора, а базовый имеет.


Основная задача при наследовании: инициализировать базовый класс. Отсюда разные варианты.

После основного конструктора через `:` вызвать конструктор базового класса:
```kt 
open class Base(p: Int)
class Derived(p: Int) : Base(p)
```
Скобки нужны в любом случае, даже если базовый не имеет основного конструктора. Интерфейсы указываются без скобок:
```kt
interface Serialaizible
class Derived(p: Int) : Base(), Serialaizible
```
Если наследник не имеет основного конструктора, значит базовый класс должен инициализироваться во вторичном конструкторе:
* вызов конструктора базового класса через `super` напрямую 
* или вызов вторичного конструктора, в котором есть вызов констр-ра базового класса, через `this`:
```kt
class Derived: Base {
    constructor(p: Int): super(p) { /* опциональное тело конструктора*/}
    constructor(p: Int, text: String): this(p) { /* опционально */}
```


[id](001.003.009)


## 010. Два способа задать геттер для свойства класса: блоком и выражением


**Полный синтаксис** - это блок кода с оператором `return`:
```kt
class Rectangle(val h: Int, val w: Int) {
    val isSquare: Boolean
        get() {
            return w == h
        }
}
```
**Сокращенный синтаксис** - выражение:
```kt
class Rectangle(val h: Int, val w: Int) {
    val isSquare: Boolean
         get() = w == h
}
```


[id](001.003.010)


## 011. Как объявить переопределение методов  при наследовании или реализации интерфейса. Обязательность модификатора `open` и его расположение в базовых классах, интерфейсах


Переопределяемые методы обязательно должны помечаться модификатором `override`:
```kt
open class Shape {
    open fun draw() { /* .. */ }
    fun fill() { /* .. */ }
}
class Circle(): Shape() {
    override fun draw() { /* .. */ }
}
```
В базовом классе модификатор `open` обязателен перед самим классом и методом. У интерфейсов не обязательно (`open` по умолчанию).


[id](001.003.011)


## 012. Как переопределить свойства при наследовании. Можно ли **val** сменить на **var**. Наоборот?


Также как и методы:
* `open` у базового класса и свойства
* `override` в наследуемом классе
```kt
open class Shape {
    open val count: Int = 0
}
class Rect: Shape() {
    override val count: Int = 4
}
```
Можно переопределять **val** в **var**, но не наоборот (для **var** добавляется новый метод - сеттер, это ок)


[id](001.003.012)


## 013. Как вызвать в производном классе методы базового класса. Как получить доступ к свойствам базового класса.


Доступ с свойствам и методам базового класса через `super`:
```kt
open class Rect {
    open fun draw() { .. }
    val color: String get() = "black"
}
class FilledRect: Rect() {
    override fun draw() {
        super.draw()
    }
    val fillColor: String get() = super.color
}
```


[id](001.003.013)


## 014. Что, если класс наследует два одинаковых метода (от класса и интерфейса например). Как вызвать метод конкретного базового класса.


1. Если наследуются два одинаковых метода, класс обязательно должен этот метод переопределить
2. Вызов конкретной реализации - через `super<...>`
```kt
open class Rect {
    open fun draw() { .. }
}
interface Polygon {
    fun draw() { .. } // open по умолчанию
}
class Square(): Rect(), Polygon {
    override fun draw() {
        super<Rect>.draw()
        super<Polygon>.draw()
    }
}
```


[id](001.003.014)


## 015. Полный синтаксис объявления свойств класса.


Внутри тела класса:
```
var <propName> [: <propType>] [= <propInit>]
    [<getter>]
    [<setter>]
```
Для read-only свойств: **val** и отсутствие сеттера
```kt
class Address {
    var name: String = ".."
}
fun copy(): Address {
    val result = Address()
    result.name = ".."
    return result
}
```


[id](001.003.015)


## 016. Как объявить геттер/сеттер. Когда они используются. Когда можно не указывать тип.


Геттер вызывается всегда, когда есть обращение к свойству:
```kt
class Rect(val w: Int, val h: Int) {
    val squre: Int
         get() = this.w * this.h
}
```
Тип можно не указывать, если его можно вывести.

Сеттер вызывается всегда, когда идет присваивание, кроме блоков инициализации.
```kt
val s: String
    set(value) {
        field = value
    }
```


[id](001.003.016)


## 017. Как установить значение свойства внутри сеттера. Ключевое слово **field**.


```kt
val counter = 0
    set(value) {
        if (value >= 0) 
             field = value
             // если counter = value - рекурсию получаем
    }
}
```
Ключевое слово **field** обеспечивает доступ к полю внутри сеттера, где конкретно хранится значение.


[id](001.003.017)


## 018. Как объявить константу. Условия, где можно применять.


Через модификатор `const`
```kt
const val SYSTEM: String = "Linux"
```
Условия применения:
* это переменная верхнего уровня, член объекта или объект-компньон
* тип - String или примитивы
* не может иметь пользовательских геттеров


[id](001.003.018)


## 019. Зачем нужны **late-initialized** свойства. Где и когда можно применять. Что будет при доступе к неинициализированной. Как проверить, что инициализировались.


Обычно свойства инициализируются в конструкторе. Но иногда это невозможно (DI, тесты). Тогда переменной присвоится значение null. Чтобы избежать этого (и связанных с этим проверок на null), можно использовать модификатор `lateinit`:
```kt
public class MyTest {
    lateinit var s: Subject
    @SetUp fun setup() {
        s = Subject()
     }
}
```
Условия применения:
* **var** свойство внутри тела класса, не в конструкторе (val нельзя т. к. инициализируется вне конструктора)
* свойство не должно иметь геттеров/сеттеров
* тип не nullable и не примитивный

При попытке доступа, если не инициализировано - будет исключение. 

Проверка: ключевое слово `isInizialized` через **ссылку на свойство**:
```kt
if (foo::bar.isInizialized) {
    println(foo.bar)
}
```


[id](001.003.019)


## 020. Как объявить интерфейс. Что может содержать.


```kt
interface MyInterface {
    fun bar()
    fun foo() { /* реализация */ }
}
```
Содержит:
* абстрактные методы
* методы с реализацией
* свойства
    - если не задан геттер - это абстрактные свойства
    - с реализованными методами доступа, но поле `field` недоступно, поэтому только геттер по факту
```kt
interface A {
    var s: String // абстрактное свойство
    var a: Int
        get() = 42
}
class Foo: A {
    override var s: String = "bar"
}
```


[id](001.003.020)


## 021. Как объявить свойство в интерфейсы. Какие варианты.


Свойства могут быть:
* абстрактными 
* с реализацией методов доступа (только геттеров) 

Т. к. интерфейсы не могут хранить состояние, нельзя задавать сеттеры (нет доступа к полю **field**)
```kt
interface MyInterface { 
    var prop1: Int // абстрактное
    var prop2: String
        get() = "foo"
    fun foo() {
        println(foo)
    }
}
class Child: MyInterface {
    override val prop: Int = 42
}
```


[id](001.003.021)


## 022. Как разрешаются конфликты при реализации нескольких интерфейсов (одинаковые методы).


В общем случае класс должен переопределять метод, который есть в нескольких интерфейсах, даже если он не абстрактный.
```kt
interface A {
    fun foo() { .. }
    fun bar() 
}
interface B {
    fun foo() { .. }
    fun bar() { .. } 
}
class C: A, B {
    override fun foo() {
        super<A>.foo()
        super<B>.foo()
    }
    override fun bar() { .. }
}
```


[id](001.003.022)


## 023. Что такое **функциональный**  интерфейс. Что такое **SAM**-интерфейс. Как объявить.


**Функциональный** интерфейс - интерфейс с единственным абстрактным методом. Он же **Single Abstract Method** (**SAM**) интерфейс.

Для объявления используется модификатор `fun`:
```kt
fun interface Serializiable {
    fun serialize()
}
```


[id](001.003.023)


## 024. К чему можно применять модификаторы видимости. Как определяется видимость геттеров / сеттеров. 4 вида модификаторов видимости. Модификатор по умолчанию.


Можно применять к:
* классам
* объектам
* интерфейсам
* конструкторам классов
* функциям
* свойствам
* сеттерам

Видимость **сеттера** можно настроить модификатором. Видимость **геттера** - как задано у свойства.

Модификаторы: **private**, **protected**, **internal**, **public**. По умолчанию - **public**. Поведение модификаторов зависит от того, к каким группам сущностей они применяются: объявление верхнего уровня или член класса.


[id](001.003.024)


## 025. Что такое **top-level**. Что там может объявляться.  Какие модификаторы видимости доступны и что значат.


**Top-level** - объявление прямо внутри пакета (прямо внутри файла, не внутри класса например). Для доступа к таким объектам не нужно создавать классы например.

Можно объявлять:
* функции
* классы
* интерфейсы
* объекты
* свойства

Для **top-level** сущностей видимость по умолчанию - **public** (видны везде, естественно при импорте пакета).

Другие модификаторы:

* **private** - доступен только внутри файла, где определен
* **internel** - доступен внутри **модуля**
* **protected** - не допускается

```kt
// файл ex.kt
package foo

private fun foo() { .. } // только внутри файла ex.kt
public var bar: Int = 42 // доступно везде
    private set                // но устанавливать только внутри ex.kt
```


[id](001.003.025)


## 026. Какие модификаторы доступны для членов класса. Что значат. Что происходит с доступностью при переопределении класса. Модификаторы у конструкторов класса.


Доступны все 4 модификатора:

* **private** - видимость только внутри класса
* **protected** - также только внутри класса + видимость в подклассах
* **internal** - видимость в пределах **модуля** у тех, у кого есть доступ к самому классу
* **public** - видимость для всех

Конструктор класса по умолчанию имеет модификатор **public**. Если указывается видимость явно - необходимо ключевое слово **constructor**:
```kt
class A private constructor(a: Int) { .. }
```


[id](001.003.026)


## 027. Что такое **модуль**. Как задать видимость в пределах модуля. Как в байт-код компилируется модификатор `internal`


**Модуль** - это набор файлов, компилируемых вместе. Например: Intellij модуль, Maven проект.

Обеспечивают инкапсуляцию. После компиляции модуля, получить доступ к элементам из области видимости модуля нельзя. Аналог из Java - видимость по пакетам, но её можно нарушить, включив класс в тот же пакет.

Для указания видимости в пределах модуля - модификатор **internal**.

При компиляции в байт-код **internal** превращается в **public** (**protected** недостаточно - в модуле могут быть несколько пакетов). Поэтому в Java можно вызвать то, что нельзя из Kotlin. Но компилятор членам класса с `internal` может добавлять суффиксы.


[id](001.003.027)


## 028. Что такое **data-классы**. Как объявляются. Что дают по умолчанию (методы). Требования к таким классам. Что c генерацией методов при наследовании.


**Data-класс** - класс, предназначенный для хранения данных.
```kt
data class User(val name: String, val age: Int)
```
Автоматически создаются:
* пара `equals()` / `hashCode()`
* `toString()` в форме `"User(name=John, age=35)"`
* функция для каждого свойства вида `componentN()`
* функция `copy()`

Требования к **data-классам**:
* должен быть первичный конструктор с минимум 1-м параметром (именно для параметров конструктора работают методы `equals()`/`hashCode()`)
* все параметры конструктора должны быть отмечены `val` или `var`
* не могут быть `abstract`, `inner`, `open`, `sealed`

Что, если методы уже есть:
* не генерируются если:
    - в теле **data-класса** есть явная реализация методов `equals()`, `hashCode()`, `toString()`
    - наследуется класс у которого есть эти методы и они `final`
* в базовом классе есть `open` методы `componentN()` с подходящими типами - они наследуются
* если их нельзя наследовать - генерируется ошибки
* явно реализовывать методы `componentN()` и `copy()` нельзя


[id](001.003.028)


## 029. Что, если объявить внутри тела **data-класса** свойство.


Такое свойство не будет включено в генерируемые функции:
* `equals()` / `hashCode()`
* `toString()`
* `componentN()`
* `copy()`

```kt
data class Person(val name: String) {
    val age: Int = 0
}
```
Здесь два объекта с разными `age` будут одинаковыми (по `equals()`)


[id](001.003.029)


## 030. Функция `copy()` **data-классов**. Реализация и пример.


Data-классы обычно для неизменяемых объектов создаются. Нужно копировать объект, может с изменением части полей.
```kt
data class User(val name: String, age: Int) {
    // псевдореализация:
    fun copy(name: String = this.name, age: Int = this.age) = User(name, age)
}
val alice = User("Alice", 25)
val olderAlice = alice.copy(age = 26)
```


[id](001.003.030)


## 031. Как выполняется **destructing declaration** для data-классов.


```kt 
data class User(val name: String, val age: Int)
val jane = User("Jane", 31)
val (name, age) = jane
println("$name, \$age years of age")
```


[id](001.003.031)


## 032. Что такое **sealed** (**запечатанные**) классы и интерфейсы. Для чего нужны. Что с видимостью конструкторов. Где могут находиться наследники таких классов.


Нужны для ограничения наследования и создания жестко заданных иерархий. Все наследники известны на этапе компиляции. После компиляции (например при использовании классов в составе библиотеки) унаследовать такие классы нельзя.
```kt
sealed interface Error
sealed class IOError: Error
```
**sealed** классы абстрактны.

Конструкторы - только **protected** (наследники, по умолчанию) или **private** (внутри класса). Т. е. создавать экземпляры таких классов могут только наследники.

Прямые наследники **sealed** классов могут находится только внутри того же пакета: на верхнем уровне или внутри sealed-класса. Видимость - любая. На непрямых наследников никаких ограничений нет.


[id](001.003.032)


## 033. Преимущество использования ```sealed-классов``` с выражением ```when```.


Поскольку наследники **sealed-класса** известны на этапе компиляции, при полном перечислении всех наследников в ветках выражения **when**, в ветке **else** нет необходимости. Если будет добавлен новый наследник, код просто не скомпилируется без добавления новой ветки.
```kt
sealed interface Error
class IOError: Error
class FileError: Error

fun log(e: Error) {
    when(e) {
        is IOError -> { .. }
        isFileError -> { .. }
        // больше вариантов нет, else не нужен
}
```


[id](001.003.033)


## 034. Где могут находится **вложенные** (**nested**) классы, интерфейсы. Как обратится к вложенному классу. Доступ к членам внешнего класса.


**Вложенный** - класс, объявленный внутри другого класса или интерфейса. Интерфейс также может быть объявлен внутри другого класса / интерфейса.
```kt
class Outer {
    private val bar: Int = 1
    class Nested {
        fun foo() = 2
    }
}
```
Обращение к вложенному - по имени внешнего:
```kt
val demo = Outer.Nested().foo()
```
У вложенного класса доступа к членам внешнего класса нет, т. е. не хранит ссылку на внешний класс. Это аналог внутреннего статического класса Java.


[id](001.003.034)


## 035. Что такое **внутренний** (**inner**) класс. Как создать. В чем отличие от **вложенного** класса.  Как получить ссылку на внешний класс.


**Внутренний** класс - это вложенный класс с модификатором **inner**:
```kt
class Outer {
    private val bar: Int = 42
    inner class Inner { 
        fun foo() = bar
    }
}
```
**Внутренний** класс имеет доступ к членам внешнего класса, т. е. хранит ссылку на внешний класс:
```kt
class Outer {
    inner class Inner {
        fun getOuter: Outer = this@Outer
    }
}
```


[id](001.003.035)


## 036. Классы-перечисления (enum). 2 варианта определения: с инициализацией и без. Обращение к свойствам перечислений.


Перечисления объявляются как класс с модификатором **enum**:
```kt
enum class Direction {
    NORTH, SOUTH, WEST, EAST
}
```
Т. к. это класс, можно инициализировать с параметром:
```kt
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00)
}
```
Теперь можно получить значение свойства:
```kt
val redColor = Color.RED
val rgb = redColor.rgb
```
Если свойство задать как **var** можно и устанавливать, зачем только.


[id](001.003.036)


## 037. Методы перечислений: получение по значению, получение массива значений. Какие свойства есть у констант перечислений.


Класс перечесления имеет методы:
```kt
EnumClass.valueOf(value: String): EnumClass
EnumClass.values(): Array<EnumClass>
```
Каждое значение перечисления имеет свойства для доступа к строковому имени и порядку (как объявлены):
```kt
val name: String
val ordinal: Int
```


[id](001.003.037)


## 038. Как определить свойства или функции в теле перечисления. Как получить доступ к ним. Как переопределить эти методы / свойства в значениях перечисления.


В теле класса перечисления можно определять свойства и методы. Они должны отделяться от значений перечисления - `;`
```kt
enum class Color {
    RED,
    GREEN;
    
    val note: String = "this is color"
    fun order(): String { return "unknown" }
```
Получить доступ к таким членам - через значение перечисления:
```kt
val redColor = Color.Red
println(redColor.note)
val order = redColor.order()
```
В значениях можно переопределять свойства / методы из тела (должны быть `open`):
```kt
enum class Color {
    RED {
         override fun warm(): String = "w"
    },
    GREEN;
 
    open fun warn(): String = "c"
}
```


[id](001.003.038)


## 039. Для чего нужны **inline-классы**. Требования к объявлению.


Иногда нужен класс, содержащий одно значение примитивного (или String) типа. Работа с примитивами оптимизирована, с обертками - уже нет. Для сохранения оптимизаций и нужны **inline-классы**.

Для объявления - ключевое слово `value` + основной конструктор с единственным свойством:
```kt
value class Password(private val s: String)
val p = Password("secret")
``` 


[id](001.003.039)


## 040. Какие члены может иметь **inline-класс**. Что про **backing field**.


Имеют частичную функциональность обычных классов. Могут иметь:
* свойства
* блоки инициализации
* функции
```kt
value class Name(val s: String) {
    val len: Int
        get() = s.lenght
    fun greet() { println(s) }
}
```
Свойства **inline-классов** не могут иметь `backing field`, поэтому только геттеры доступны.


[id](001.003.040)


## 041. Наследование классов и интерфейсов для **inline-классов**.


Могут реализовывать интерфейсы:
```kt
interface Printable {
    fun print(): String
}
value class Name(val s: String): Printable {
    override fun print(): String = "Lets $s"
}
```
Не могут наследовать классы и сами являются финальными.


[id](001.003.041)


## 042. Каково внутреннее представление **inline-классов**. Что с равенством по ссылке. В чем суть **mangling**. Зачем нужен для **inline-классов**.


Внутреннее представление - простой финальный класс класс с геттером и сеттером и полем примитивного типа. Когда невозможно примитивный тип использовать (например nullable тип или реализует интерфейс) - обертка над примитивным.

Проверка на равенство по ссылке не разрешена, т. к. тип может быть или примитивным, или оберткой одновременно:
```kt
value class U(p: Int)
val a1 = U(4)
val a2 = U(5)
//val bool = a1 === a2 // ошибка компиляции
```
**Mangling** (коверканье) - техника, используемая в компиляторах, для обеспечения уникальности имен. Применительно к inline-классам: в некоторых случаях сигнатуры функций могут совпадать, для различения к именам добавляется хеш-код:
```kt
value class SomeInt( val x: Int)
fun compute(p: Int) { .. }
fun compute(p: SomeInt) { .. } 
// представление обеих функций: public final void compute(int p)
```


[id](001.003.042)


## 043. Суть ключевого слова **object**. 3 случая использования.


Основная идея: одновременно объявляет класс и создает его экземпляр (объект).

3 ситуации, когда используется:
* объявление объекта как реализация шаблона **Singleton**
* реализация **объекта-компаньона**, содержащего:
    - фабричные методы
    - методы, связанные с классом, но требующие обращения к экземпляру. Вызов таких методов - по имени класса, без экземпляра (аналог `static` методов Java)
* создание **объекта-выражения** - аналог анонимного внутреннего класса Java


[id](001.003.043)


## 044. Использование **object** для реализации шаблона **Singleton** - **object declaration**. Синтаксис **object declaration**. Вызов методов объекта. Что про свойства, методы, конструкторы, наследование, интерфейсы. Где можно объявлять. Особенность, если внутри обычного класса.


Через синтаксис **объявления объекта** (**object declaration**): объявление класса + создание единственного экземпляра.

Синтаксис: ключевое слово **object** + имя + тело. Это не выражение, не может быть справа от присваивания.
```kt
object DataProviderManager {
   fun register(provider: DataProvider) {
      // ... 
   }
}
```
Вызов методов - через имя объекта:
```kt
DataProviderManager.register(NoSqlDataProvider())
```

Может содержать свойства, методы, блоки инициализации. Конструкторы не допускаются (ведь объект создается сразу в месте объявления).

Может наследовать классы, интерфейсы.

Объявлять можно на верхнем уровне, внутри класса. Внутри функции нельзя. Если внутри класса - в единственном экземпляре на все объекты класса-владельца (внутри хранится в статическом поле класса с именем `INSTANCE`).


[id](001.003.044)


## 045. Объекты-компаньоны: для чего, отличие от функций верхнего уровня. Синтаксис объявления. Что с именем. Доступ к свойствам и методам. Пример реализации фабричного метода.


Как реализация статических функций. Также в качестве статических функций могут выступать функции верхнего уровня, но у них нет доступа к приватным членам классов. Объекты-компаньоны имеют доступ к приватным конструкторам классов, в которых объявлены, к другим членам -  доступа нет. Часто используются для фабричных методов.

Синтаксис: `companion object` + тело, можно без имени. Внутри класса можно только один компаньон объявить.
```kt
class A {
    companion object {
        fun create(): A = A()
    }
}
class B {
    companion object Factory {
        fun create(): B = B()
    }
}
```
Доступ к членам объекта-компаньона можно прямо по имени класса-владельца или через имя компаньона. Если компаньон объявлен без имени - доступ к нему через **Companion**
```kt
val a1 = A.create() 
val a2 = A.Factory.create()
val b1 = B.create()
val b2 = B.Companion.create()
```
**Фабричный метод**: делаем приватный конструктор и создаем компаньон с фабричным методом:
```kt
class A private constructor(var foo: Int) {
    companion object {
        fun create(p: Int) = A(p)
    }
}

val a = A.create(42)
```


[id](001.003.045)


## 046. Как объекты компаньоны реализуют интерфейсы. Что можно присвоить переменной с типом интерфейса.


Объекты-компаньоны могут реализовывать интерфейсы:
```kt
interface Runnable {
    fun run()
}
class A {
    companion object: Runnable {
         override fun run() { ... }
}
```
Теперь сам класс является переменной типа интерфейса (статический экземпляр компаньона внутри класса):
```kt
val foo: Any = A
println(foo is Runnable) // true
// но экземпляр нет
val bar: Any = A()
println(bar is Runnable) // false
```


[id](001.003.046)


## 047. **Объекты-выражения** (**object expression**): суть / аналог в Java Синтаксис объявления, где могут объявлятся (2 варианта). Что если не реализуют / наследуют интерфейсы/ классы, как доступ к членам. Что с наследованием / реализацией. Внутреннее представление. Что с доступом из объекта-выражения к переменным функции-владельца.


**Объекты-выражения** - это аналог анонимных классов в Java.

Объявляются в переменных функций. Можно присвоить локальной переменной. Синтаксис: ключевое слово `object` + реализуемый интерфейс / класс (опционально) + тело. Имени нет.

```kt
window.addMouseListener(
    object: MouseAdapter() {
        override fun mouseClicked(e: Event) { .. }
    }
}
```
Могут не реализовывать интерфейсы / наследовать классы. Доступ к членам объекта - через переменную, которой присвоен:
```kt
val foo = object {
    val bar = 42
    fun say() {
        println("Hello")
    }
}
println(foo.bar)
foo.say()
```

Могут реализовывать несколько интерфейсов (в отличие от Java). Внутреннее представление - анонимный класс. Не являются синглтонами.

Код в методах объекта-выражения может обращаться к переменным функции, где объявлен и не обязательно финальных (как в Java):
```kt
fun countClick(w: Window) {
    var counter = 0
    w.addListener(object: MouseAdapter() {
        override fun mouseClicked(e: Event) {
            counter++
        }
    })
}
```


[id](001.003.047)


## 048. **object declaration** vs **object expression** vs **companion object**: * суть * пример объявлений и использований * где можно объявлять * когда инициализируются


Суть:
* **OD** - синглетон
* **OE** - анонимный класс
* **CO** - статический член класса / функции

Примеры объявлений и использования:
```kt
// OD:
object A {
    fun register() { .. }
}
A.register()

// OE:
val b = object {
    val foo = 42
}
println(b.foo)

// CO:
class C {
    companion object {
        fun create() = C()
    }
}
val c = C.create()
```
Где можно объявлять:
* **OD** - верхний уровень, внутри класса
* **OE** -в любом месте
* **CO** -  внутри класса

Когда инициализируются:
* **OD** - ленивая инициализация, инициализируются когда вызывается метод первый раз
* **OE** - сразу как используются / объявляются
* **CO** - инициализируются в момент загрузки класса (как статический член класса)


[id](001.003.048)


## 049. Что такое **свойства**.  Способы объявления (где можно). Когда создаются геттеры, сеттеры. Виды свойств (по созданию методов доступа).


**Свойство** (**property**) - это сочетание поля класса и методов доступа.

Объявление:
* в главном конструкторе класса через **val** или **var**
* внутри тела класса
```kt
class Person(val name: String)

class User {
    val name = "Bob"
}
```

Для **val** создается геттер, для **var** - и геттер, и сеттер. Можно объявлять свои собственные.

Виды свойств:
* простые для хранения значений без специальных методов доступа
* не хранящие состояния и использующие метод доступа для получения значения
* хранящие состояние, и использующие логику для доступа или установки (через **field**) значения
```kt
class Rect {
    val a: Int            // простое поле с геттером
    val b: Int
    val square: Int    // без состояния
        get() = a * b 
    var color: String = "" // с установкой через field
        set(value: String) {
            println("Color set to " + value)
            field = value
       }
}
```


[id](001.003.049)


## 050. 3 способа реализации свойства, объявленного в интерфейсе.


В интерфейсах можно объявить свойства, но без реализации методов доступа:
```kt
interface User {
    val nickname: String
}
```
Класс, реализцющий интерфейс должен переопределить это свойство:
* через конструктор
* через тело
    - без хранения какого-либо значения в поле (вычисляемое по другим полям)
    - с хранением значения

```kt
class PrivateUser(override val nickname: String): User

class UserWithEmail(val email: String): User {
    override val nickname:String
        get() = email.substringBefore('@')
}

class UserFromGithub(val id: Long): User {
    override val nickname = getUserNameFromGithub(id)
}
```


[id](001.003.050)


## 051. Для чего нужны **расширения**. Синтаксис объявления **функций-расширений**. Ключевое слово **this** внутри функции-расширения.


**Расширения** (**extensions**) используются для добавления в классы новой функциональности без их изменения, наследования или использования паттернов типа *Декоратор*.
 
**Функция-расширение** - функция, которая может вызываться как член класса, но объявлена вне его. Добавляем имя **типа-получателя** (**receiver type**) перед именем функции:
```kt
fun MutableList<Int>.swap(idx1: Int, idx2: Int) { .. }
 
val list = mutableListOf(1, 2, 3)
list.swap(0, 2)
```
 
**this** внутри тела функции-расширения ссылается на **объект-получатель** (**receiver object**), на котором эта функция вызвана.


[id](001.003.051)


## 052. Разрешение функций-расширений: по типу-получателю (пример)


**Функции-расширения разрешаются статически**, а не в рантайме. Например для суперкласса и подкласса объявлены одинаковые функции-расширении. Какая будет вызвана - определяется типом переменнов на этапе компиляции:
```kt
open class Shape
class Rect: Shape()

fun Shape.getName() = "Shape"
fun Rect.getName() = "Rect"

fun printName(s: Shape) {
    println(s.getName())
}

printName(Rect()) // "Shape"
```


[id](001.003.052)


## 053. Разрешение функций-расширений: совпадение с методами расширяемого класса.


1. Если объявлена функция-расширение с такой же сигнатурой как родной метод класса - вызвать нельзя. **Родной метод класса всегда перекрывает функции-расширения** (shadow):
```kt
class Example {
    fun printType() { println("Class method") }
}
fun Example.printType() { println("Extension fun") }

Example().printType() // "Class method"
```

2. Но **допустимо переопределять методы по сигнатуре**:
```kt
fun Example.printType(i: Int) { println("Extension fun #$i") }

Example().printType(4) // "Extension fun 4"
```


[id](001.003.053)


## 054. Как функции-расширения работают с nullable-типами.


Вполне допустимо объявить для nullable-типа. Внутри функции можно проверить на null и выполнять операции уже на не null-значении:
```kt
fun Any?.toString(): String {
    if (this == null) return "null"
    // smart cast, not nullable
    return toString()
}
```


[id](001.003.054)


## 055. Свойства-расширения: синтаксис объявления, что разрешено, ограничения. Пример изменяемого свойства-расширения (lastChar)


Синтаксис как у функций-расширений: `<имя типа>.<имя свойства>`:
```kt
val <T> List<T>.lastIndex: Int
    get() = size - 1
```
Что можно: объявлять геттеры и сеттеры.

Ограничения: в существующий класс ничего не добавляется, поэтому не может иметь поля для хранения значения (backing field). Следствия этого:
* не может иметь геттера по умолчанию, обязательно явно нужно задавать
* нельзя инициализировать свойство-расширение
* нет доступа к **field**

Пример изменяемого:
```kt
var StringBuilder.lastChar: Char 
    get() = get(length - 1)
    set(value: Char) {
         this.setCharAt(length - 1, value)
    }
}
``` 


[id](001.003.055)


## 056. Как объявлять и вызывать функции-расширения для объекта-компаньона.


Объявляются как для обычного класса, только через доступ к компаньону (по имени объекта-компаньона или по ключевому слову **Companion**):
```kt
class MyClass {
    companion object { }
}
fun MyClass.Companion.printCompanion() { .. }
```

Вызов как и любого метода компаньона - через имя класса:
```kt
MyClass.printCompanion()
```


[id](001.003.056)