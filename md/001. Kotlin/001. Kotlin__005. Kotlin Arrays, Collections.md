## 001. Что такое массив в Kotlin. Когда стоит использовать.


Массивы в Kotlin это экземпляры параметризованного класса **Array**.

Т. е. в массивах не хранятся примитивные типы, только их обертки.

Предпочтительнее использовать коллекции. Массивы следует использовать, если нужно вызывать код Java, где используются массивы.


[id](001.005.001)


## 002. 3 способа создания массива: * из перечня значений * массив из `null` * через конструктор


1. Функция `arrayOf()` универсального типа или аналоги с конкретным типом:
```kt
val x = arrayOf(1, 2, 3)
val y = longArrayOf(1, 2, 3)
```

2. Функция `<T> arrayOfNulls(size: Int)` создает массив заданного размера, заполненный `null`
```kt
val a = arrayOfNulls<String>(5)
```

3. Использование конструктора класса **Array** `constructor(size: Int, init: (Int) -> T)` (в функцию инициализации передается индекс):
```kt
val a = Array(4) { it + 3 }
```


[id](001.005.002)


## 003. Как преобразовать коллекцию в массив.


Через метод коллекций `toTypedArray()`.

Сигнатура метода:
```kt
actual inline fun <reified T> Collection<T>.toTypedArray(): Array<T> { .. }
```

```kt
val list = listOf(1, 2, 3)
val array = list.toTypedArray()
```


[id](001.005.003)


## 004. Как создать массив данных примитивного Java-типа. 3 способа.


Специальные классы `IntArray`, `ByteArray` и т. п. Преобразуются в стандартные массивы Java `int[]` и т. п.

1. Конструктор с указанием размера, значения - значения по умолчанию для типа:
```kt
val a = IntArray(3) // int[] {0, 0, 0}
```

2. Фабричные методы типа **intArrayOf** и подобные, с указанием значений массива:
```kt
val a = intArrayOf(1, 2) // int[] {1, 2}
```

3. Конструкторы с размером и лямбдой для генерации на основе индекса:
```kt
val a = IntArray(2) { it + 2 } // int[] {2, 3}
```


[id](001.005.004)


## 005. Чем отличаются классы **Array** и **IntArray**.


**Array** - это типизированный класс. Внутреннее представление - Java-массив, хранящий ссылочные типы (обертки).

**IntArray** - также Java-массив, но хранит примитивные типы `int`


[id](001.005.005)


## 006. Как получить массив примитивного типа из массива ссылочного типа или коллекции.


Через метод **toIntArray()** и подобные.

Есть у коллекций и ссылочных массивов.

```kt
val list = listOf(1, 2, 3)
val a = list.toIntArray()

val array = arrayOf(1, 2, 3)
val b = array.toIntArray()
```


[id](001.005.006)


## 007. Интерфейсы, лежащие в основе коллекций.


1. В основе - интерфейс **Collection<T>**, который реализует **Iterable<T>**:
```kt
public interface Collection<out E> : Iterable<E> { .. }
```
Содержит методы по проверке на пустоту, вхождение элемента или другой коллекции, получение итератора.

2. Интерфейс **MutableCollection<T>** наследует **Collection** и **MutableIterator**. 
```kt
public interface MutableCollection<E> : Collection<E>, MutableIterable<E> { .. }
```
Добавляются методы удаления, добавления, очистки.

3. Интерфейсы **List**, **Set** и мутабельные аналоги **MutableList**, **MutableSet** наследуют **Collection** и **MutableCollection**:
```kt
public interface List<out E> : Collection<E> { .. }
public interface MutableList<E> : List<E>, MutableCollection<E> { .. }
```
4. Отдельно интерфейс **Map** и **MutableMap**:
```kt
public interface Map<K, out V> { .. }
public interface MutableMap<K, V> : Map<K, V> { .. }
```


[id](001.005.007)


## 008. Особенности коллекции **List**. В чем отличие от **Array**.


Особенности:
* упорядоченные набор элементов
* есть доступ по индексу
* допускает дубли

Размер массива жестко задан при создании. Размер списка может динамически менятся.


[id](001.005.008)


## 009. Особенности коллекции **Set**. Сколько может содержать **null**.


Особенности:
* содержит уникальные значения
* порядок элементов в общем случае не задан

Элемент со значением `null` может быть только один в коллекции.


[id](001.005.009)


## 010. Классы-реализации интерфейса **Set**.  Отличия. Что это с точки зрения реализации.


Реализация по умолчанию - **LinkedHashSet**. Сохраняет порядок вставки элементов.

Поэтому функции, завязанные на порядок, (например `first()` или `last()` из интерфейса `Iterable`) дают предсказуемый результат.

**HashSet** - реализация, без порядка в элементах. Занимает меньше памяти.

В реализации это обычные коллекции Java:
```kt
public actual typealias HashSet<E> = java.util.HashSet<E>
public actual typealias LinkedHashSet<E> = java.util.LinkedHashSet<E>
```


[id](001.005.010)


## 011. Особенности коллеции **Map**. Классы, реализующие интерфейс. Как реализованы эти классы.


Особенности:
* содержит пары ключ-значение
* ключи уникальны
* значения необязательно

В иерархии интерфейсов коллекций не наследуют `Collection`

Реализация по умолчанию - **LinkedHashMap**: порядок ключей определен. Реализация **HashMap** - порядок ключей не задан.

Всё это - обычные Java коллекции:
```kt
public actual typealias LinkedHashMap<K, V> = java.util.LinkedHashMap<K, V>
public actual typealias HashMap<K, V> = java.util.HashMap<K, V>
```


[id](001.005.011)


## 012. Создание коллекций через методы типа xxxOf(). Как мутабельные создать. Как создать **Map**. Что такое **to**.


1. Методы типа **listOf**, **setOf()**. Принимают `varargs`.

Тип может вывести, если параметров - нет, нужно явно указавыть:
```kt
val list = listOf(1, 2, 3)
// но
val emptyList: List<String> = listOf()
```

2. Мутабельные коллекции создаются аналогичными методами:
```kt
val list = mutableListOf(1, 3, 5)
```

3. **Map** можно создать из `varargs` экземпляров класса **Pair**.

У этого класса определена функция `to()`:
```kt
infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
```
Можно создавать:
```kt
val numbersMap = mapOf("key1" to 1, "key2" to 2)
```
Не очень эффективное решение (промежуточные объекты **Pair** создаются)


[id](001.005.012)


## 013. Создание коллекций через методы **buildXXX()**. Сигнатура методов.


Сигнатура:
```kt
public inline fun <E> buildList(builderAction: MutableList<E>.() -> Unit): List<E> { .. }
```
Т. е.  создают через мутабельную коллекцию и возвращают read-only коллекцию:
```kt
val list = buildList {
    add(1)
    add(2)
}
val map = buildMap {
    put("a", 1)
    put("b", 2)
}
```


[id](001.005.013)


## 014. Методы создаения пустых коллекций. Особенности. Тип созданной коллекции.


Методы типа **empttList()**, **emptySet()**, **emptyMap()**.

Обязательно указание типа элементов.

Создают read-only коллекции.
```kt
val list = emptyList<String>()
val map = emptyMap<String, Int>()
```


[id](001.005.014)


## 015. Создание списка через метод с размером и лямбдой по индексам.


```kt
val doubled = List(5) { it * 2 }
```
Возвращает read-only список.


[id](001.005.015)


## 016. Создание коллекций через конструкторы классов-реализаций. Какой тип и какой тип у элементов.


Используются конструкторы Java-классов. При этом тип коллекции - это Java-тип, а тип элементов - **платформенный**:
```kt
val linkedList = LinkedList(listOf("a", "b"))
// тип - LinkedList<String!>
```
Аналогично **HashSet**, **ArrayList**, **HashMap** и т. п.


[id](001.005.016)


## 017. Как скопировать коллекцию в другую коллекцию. Что такое **shadow copy**.


Методы **toList()**, **toSet()**, **toMutableList()** и т. п. Создают теневую копию коллекции. Т. е. элементы в коллекциях ссылаются на одни и те же объекты.

```kt
val list1 = mutableListOf(1, 2, 3)
val list2 = list1.toList()
```

Можно из одного типа в другой:
```kt
val list = listOf(1, 2, 3)
val set = list.toSet()
```


[id](001.005.017)


## 018. Что такое **Iterable** и **Iterator**. Их методы. Обход элементов с помощью итератора.


**Iterable** - это интерфейс с единственным методом, который возвращает экземпляр **Iterator**:
```kt
public interface Iterable<out T> {
    public operator fun iterator(): Iterator<T>
}
```

**Iterator** - это также интерфейс с методами получения следующего элемента:
```kt
public interface Iterator<out T> {
    public operator fun next(): T
    public operator fun hasNext(): Boolean
}
```
Итератор можно получать у коллекций, реализующих **Iterable** (**List**, **Set**):
```kt
val list = listOf(1, 2, 3)
val iter = list.iterator()
while (iter.hasNext()) {
    println(iter.next())
}
```


[id](001.005.018)


## 019. 3 способа обхода коллекций, реализующий **Iterable**.


1. Обход через итератор:
```kt
val numbers = listOf("one", "two", "three", "four")
val iter = numbers.iterator()
while (iter.hasNext()) {
    println(iter.next())
}
```
2. Через цикл **for** (неявное использование итератора):
```kt
val numbers = listOf("one", "two", "three", "four")
for (item in numbers) {
    println(item)
}
```
3. Функция **forEach()** с лямбдой:
```kt
val numbers = listOf("one", "two", "three", "four")
numbers.forEach {
    println(it)
}
```


[id](001.005.019)


## 020. Особый итератор для списков **ListIterator**. Как получить.  Отличия от стандартного.


Специальный итератор для коллекций на основе индексов.

Получить можно у экземпляров **List** через метод **listIterator()**.

Наследует методы обычного **Iterator** + добавляет методы для обращения к предыдущим значениям и следующему / предыдущему индексу:
```kt
val list = listOf(1, 2)
val listIter = list.listIterator()

while(listIter.hasNext()) {
    println(listIter.next())
    println(listIter.nextIndex())
}

while(listIter.hasPrevious()) {
    println(listIter.previous())
    println(listIter.previousIndex())
}
```


[id](001.005.020)


## 021. Что такое **MutableIterator**. Как получить. Что дает **MutableListIterator**.


**MutableIterator** это наследник обычного итератора с дополнительным методом **remove()**. 

Получить можно через метод **iterator()** у мутабельных коллекций:
```kt
val list = mutableListOf(1, 2, 3)
val iter = list.iterator()

iter.next()while(listIter.hasNext()) {
    println(listIter.next())
    println(listIter.nextIndex())
}
iter.remove()
```

**MutableListIterator** дополнительно имеет методы для добавления **add()** и изменения значений **set()**


[id](001.005.021)


## 022. Функции **rangeTo**, **downTo**, **step**, **until**. Их сигнатуры. Что создают.


Функция **rangeTo** (и ее оператор **..**) - создание диапазона. Сигнатура:
```kt
public operator fun rangeTo(other: Int): IntRange
```
Аналогичные есть для `Long`, `Char`

Инфиксная функция **downTo** - создание прогрессии:
```kt
public infix fun Int.downTo(to: Int): IntProgression
```
Инфиксная функция **step** создает прогрессию с заданным шагом на основании другой прогрессии:
```kt
public infix fun IntProgression.step(step: Int): IntProgression
```
Инфиксная функция **until** создает диапазон, не включая верхнюю границу:
```kt
public infix fun Int.until(to: Int): IntRange
```

```kt
val a = 5.rangeTo(7) // 5<= x <=7
val b = 5 .. 7 //  5<= x <=7
val c = 5 downTo 1 // 1 <= x <= 5
val d = 5 until 7 // 5 <= x < 7
```


[id](001.005.022)


## 023. Что такое **Range**. Какие элементы может содержать. Как создать, какие операции доступны.


**Range** (**диапазон**) определяет интервал по двум границам. Обе границы включены в интервал. Может содержать элементы, реализующие **Comparable**.

Создается с помощью функции **rangeTo()** или ее оператора `..`. Основная операция - проверка вхождения в диапазон: функция **contains()** (оператор **in**):
```kt
val range = 1 .. 10
for (i in range) {
    println()
}
```


[id](001.005.023)


## 024. Что такое **Progression** (**последовательность**). Как создать. Какой интерфейс реализуют.


Это классы **IntProgression**, **LongProgression** и **CharProgression**.

Содержат начальное значение, конечное значение и шаг.

Создать можно через:
* **rangeTo** или **until** (диапазоны целых и символов наследуют соответствующие классы последовательностей)
* **downTo**
* из существующей прогрессии через **step**
* или через **reversed()**

Прогрессии реализуют интерфейс **Iterable**, поэтому могут использоваться с функциями коллекций:
```kt
println((1..10).filter { it %  2 == 0 })
```


[id](001.005.024)


## 025. Для чего нужны **последовательности** (**sequence**). Интерфейс **Sequence**. Сравнение с **Iterable**.


Аналог iterable-коллекций. Но обычные коллекции во время операций типа **filter** или **map** создают промежуточные коллекции на каждом шаге. Последовательности не создают промежуточные коллекции и более эффективны для коллекций большого размера. 

Интерфейс:
```kt
public interface Sequence<out T> {
    public operator fun iterator(): Iterator<T>
}
```

Сравнение **Sequence** и **Iterable**:
* при обработке в несколько шагов **Iterable** полностью обрабатывает один шаг, создавая промежуточную коллекцию, затем переходя к другому шагу
* **Sequence** обрабатывает шаги лениво. Полностью вычисления выполняются, когда затребуется результат
* **Sequence** для каждого элемента выполняет всю цепочку операций, затем переходит к следующему. **Iterable** - одну операцию на всех элементах, затем к следующей операции


[id](001.005.025)


## 026. 4 способа создания последовательностей


1. Из элементов, через функцию **sequenceOf()**:
```kt
val seq = sequenceOf("one", "two")
```

2. Из коллекций или массивов функцией **asSequence()**:
```kt
val list = listOf(1, 2, 3)
val seq = list.asSequence()
```

3. Генерацией через функцию **generateSequence()**. Такая последовательность может быть бесконечной. Для создания конечной - функция должна возвращать `null` на каком-то шаге.

Параметры функции: начальный элемент и функция, вычисляющая значение элемента через предыдущий:
```kt
val s1 = generateSequence(1) { it + 2 } // бесконечная 1, 3, 5, ...
val s2 = generateSequence(1) { if (it < 8) it + 2 else null }
```

4. Из кусочков с помощью функций **yield**
```kt
val seq = sequence {
    yield(1)
    yieldAll(listOf(2, 3, 4)
}
```


[id](001.005.026)


## 027. Виды операций над последовательностями. Различие в выполнении операций над коллекциями и последовательностями. Важность порядка операций (filter и map). Связь последовательностей и Stream из Java 8.


Операции над последовательностями:
* **промежуточные** (**intermediate**) - возвращает другую последовательность ( `map()`, `filter()` и др.)
* **терминальные** (**terminal**) - возвращает результат преобразования последовательности: коллекция, число или др. (`toList()`, `sum()`, `count()` и др.)

Выполнение промежуточных операций всегда откладывается до начала выполнения терминальных.

При **обработке коллекций** - каждая операция выполняется сначала над всеми элементами коллекции, затем получившаяся коллекция передается на вход другой операции. **В последовательностях** один элемент обрабатывается сразу всеми операциями, затем переход с следующему элементу.

Порядок важен: сначала отфильтровать, потом преобразовать.

С Stream из Java 8 не связаны: собственная реализация. Например не поддерживается параллельная обработка операций.


[id](001.005.027)


## 028. Общее деление функций работы с коллекциями (по месту объявления). Классы-шаблоны для создания новых коллекций. Тип возвращаемого значения для операций над коллекциями. Особенность операций с постфиксом **To**. Два вида write-операций.


Функции для работы с коллекциями объявлены:
* как **функции-члены** интерфейсов (важные функции типа `isEmpty()`)
* как **функции-расширения**

Для создания собственных коллекций - абстрактные классы **AbstractCollection**, **AbstractList**, **AbstractSet**, **AbstractMap** и их мутабельные варианты.

Обычно операции возвращают новую коллекцию, текущую не изменяют:
```kt
val list = listOf(1, 2, 3)
val newList = list.filter { it > 2 }
```
Функции с постфиксом **To** принимают параметром коллекцию-получатель (мутабельную). Дополнительно для удобства также возвращают результирующую коллекцию:
```kt
val numbers = listOf("one", "two")
val filterResult = mutableListOf<String>()
numbers.filterTo(filterResult) { it.length > 3 }
```  

Операции, изменяющие коллекции, обычно в паре: изменяет текущую коллекции или создает новую. Например пара `sort()` и `sorted()`
```kt
val nums = mutableListOf("one", "two")
val sortedNums = nums.sorted() // nums != sortedNums
nums.sort()   // теперь nums == sortedNums
```


[id](001.005.028)


## 029. Сущность операции трансформации **map**. Варианты функции (3 шт) Особенности для коллекций **Map**.


Операция **map** создает новую коллекцию, путем преобразования каждого элемента исходной через некоторую функцию.

1. Стандартная: функция для каждого элемента
```kt
val numbers = setOf(1, 2, 3)
val doubled = numbers.map { it * 2 }
```
2. С доступом к индексу
```kt
val newSet = numbers.mapIndexed { idx, value -> value * idx }
```

3. Отбрасывая `null` в результате:
```kt
val s = numbers.mapNotNull { if (it == 2) null else it * 2}
val s2 = numbers.mapIndexedNotNull { idx, value -> ... }
```

Для **Map** есть две функции: **mapValues()** - для изменений значений, **mapKeys()** - для изменения ключей. Лямбды для обеих принимают **entry**, поэтому есть доступ и к ключам, и к значениям:
```kt
val map = mapOf("key1" to 2, "key2" to 3)
val map2 = map.mapKeys { it.key.uppercase() }
val map3 = map.mapValues { it.value + it.key.length }
```


[id](001.005.029)


## 030. Сущность операции трансформации **zip**.  Что если размеры коллекций различны. Результат применения к спискам или массивам. Форма с функцией преобразования. Обратная функция. Условия применения. Результат.


**zip** создает коллекцию путем объединения элементов двух коллекций на одинаковых позициях в пары.

Если размеры коллекций различаются - размер результирующий = размеру меньшей (чтобы были полные пары).

Результат применения к спискам или массивам - **List<Pair>**. Есть инфиксная форма:
```kt
val colors = listOf("red", "brown", "blue")
val aminals = listOf("fox", "bear")
val pair = colors.zip(animals)
// colors zip animals
```

Есть форма с функцией преобразования. Функция принимает элемент первой коллекции и второй коллекции. Результат функции помещается в список:
```kt
val listOfAnimals = colors.zip(animals) { color, animal -> color + " " + animal } // List<String>
```

Обратная функция **unzip**: принимает массив или коллекцию (**Iterable**) из **Pair**. Возвращает пару списков, раскидав элементы пар по спискам:
```kt
val pairs = listOf(1 to 2, 3 to 4)
val pairOfList = pairs.unzip() // ([1, 3], [2, 4])
```


[id](001.005.030)


## 031. Сущность операции трансформации **associate**. 3 варианта функций **associate...**


Позволяет создать **Map** из элементов коллекции и некоторых значений, ассоциированных с элементами коллекций (через функцию).

1. **associateWith** создает **Map**, с ключами из коллекции, значения - результат применения переданной функции к элементам коллекции. При одинаковых элементах в коллекции - остается последний:
```kt
val list = listOf("one", "two")
val map = list.associateWith { it.length }
// { one=3, two=3 }
```

2. **associateBy** создает **Map**, ключи - результат применения функции к элементам коллекции, значения - элементы коллекции.
```kt
val list = listOf("one", "two")
val m = list.associateBy { it.first() }
// { o=one, t=two }
```
Также можно передать функцию для преобразования значений:
```kt
val m = list.associate( keySelector = { it.first }, valueTransform = { it.length } )
// { o=3, t=3 }
```

3. **associate** принимает функцию, возвращающую **Pair**, ключ и значения для карты.


[id](001.005.031)


## 032. Сущность операций трансформации **flatten** и **flatMap** Примеры сигнатур.


**flatten** разворачивает коллекцию вложенных коллекций в список их элементов:
```kt
val nested = listOf(setOf(4, 5, 6), setOf(1, 2))
val flat = nested.flatten()
// [4, 5, 6, 1, 2]
```

**flatMap** к каждому элементу коллекции применяет переданную функцию, которая преобразует элемент в коллекцию. Элементы полученных коллекций разворачиваются в список:
```kt
val list = listOf("123, "45")
val nums = list.flatMap { it.toList() }
// [1, 2, 3, 4, 5]
```

Сигнатуры:
```kt
fun <T> Iterable<Iterable<T>>.flatten(): List<T>

inline fun <T, R> Iterable<T>.flatMap(
    transform: (T) -> Iterable<R>
): List<R>
```


[id](001.005.032)


## 033. Функции для строкового представления коллекций. 2 варианта. Пример сигнатуры с параметрами.


**joinToString()** создает строку по переданным параметрам.

**joinTo()** дополнительно принимает **Appendable** объект, как начало строкового представления.

```kt
val list = listOf("one", "two")
list.joinToString() // "one, two"

val listString = StringBuffer("The list: ")
list.joinTo(listString) // "The list: one, two"
```

Есть возможность указать префикс, постфикс, разделитель, лимит, представление для сверхлимита, функцию для преобразования элементов через именованные параметры:
```kt
fun <T> Iterable<T>.joinToString(
    separator: CharSequence = ", ",
    prefix: CharSequence = "",
    postfix: CharSequence = "",
    limit: Int = -1,
    truncated: CharSequence = "...",
    transform: ((T) -> CharSequence)? = null
): String
``` 


[id](001.005.033)


## 034. Методы для фильтрации коллекций: результат. Базовый метод **filter**: суть, результат применения к разным типам коллекций. Разные методы фильтров: 1. фильтрация с учетом индексов 2. фильтрация по отрицательному результату 3. фильтрация по типу 4. исключение `null`


Результат методов фильтрации - новая коллекция. Поэтому можно применять к read-only и к мутабельным коллекциям.

Метод **filter()**: отбирает элементы из коллекции по предикату. Для **List** и **Set** возвращает **List**, для **Map** - **Map**:
```kt
val nums = listOf("one", "two", "three")
val longerThan3 = nums.filter { it.length > 3 }
```
```kt
val map = mapOf("key1" to 1, "key2" to 2)
val filtered = map.filter { (key, value) -> key.length < 5 &amp;&amp; value > 2 }
```

1. Для учета индексов - **filterIndexed()**:
```kt
val filtered = nums.filteredIndexed { idx, s -> idx != 0 &amp;&amp; s.length > 4 }
```

2. Можно отбирать, когда условие предиката ложно с помощью **filterNot()**:
```kt
val filtered = nums.filterNot { it.length < 4 }
```

3. **filterisInstance<T>()** фильтрует по типу. Например применяя к `List<Any>` получим `List<T>`:
```kt
val nums = listOf(null, 1, "one", 2, "two")
val strings = nums.filterIsInstance<String>() 
// ["one", "two"]
```

4. **filterNotNull()** - исключение `null` из коллекции. Применяя к **List<T?>** получим **List<T: Any>**:
```kt
val nums = listOf(null, 1, 2)
val pure = nums.filterNotNull()
``` 


[id](001.005.034)


## 035. Суть функции **partition()**. Для каких классов определена.


**partition()** делит коллекцию на две части. В первую попадают элементы, удовлетворяющие предикату, во вторую - остальные. Результат - **Pair**, содержащий 2 списка:
```kt
val nums = listOf("one", "two", "three")
val (match, rest) = nums.partition { it.length > 3 }
```

Как и другие функции работы с коллекциями, определена для классов **Array** и **Iterable**.


[id](001.005.035)


## 036. Функции проверки предикатов **any()**, **none()**, **all()**: суть. Результаты для пустых / непустых коллекций.


Возвращают булево значение.

**any()** возвращает `true`, если:
* хотя бы один элемент удовлетворяет предикату
* вызвана без предиката и коллекция не пуста

**none()** возвращает `true`, если:
* ни один элемент не удовлетворяет
* вызвана без предиката и коллекция пуста

**all()** возвращает `true`, если:
* все элементы удовлетворяют предикату
* пустая коллекция (**vacuous truth**)

```kt
val nums = listOf("one", "two")

nums.any { it.endsWith("e") // true
nums.none { it.endsWith("r") // true

emptyList<Int>().all { it > 5 } // true
```


[id](001.005.036)


## 037. Суть применения функций **plus()** и **minus()** и их операторов к коллекциям.


Первым операндом - коллекция, вторым - отдельный элемент или коллекция. Возвращают read-only коллекцию.

Результат **plus()** (**+**): коллекция из элементов первой коллекции и второй (внутри вызов **addAll()**):
```kt
val list1 = listOf("one", "two")
val list2 = listOf("three")
val res = list1 + list2
// ["one", "two", "three"]
```

Результат **minus()** (**-**): коллекция из элементов первой за исключением второго элемента / элементов. Если второй операнд - элемент, исключается первое вхождение. Если коллекция - все вхождения:
```kt
val numbers = listOf("one", "two", "three", "three")
val sub = numbers - "three"
// ["one", "two", "three"]
```


[id](001.005.037)


## 038. Суть функции **groupBy()**. Вариант с двумя лямбдами.


Принимает лямбду, возвращает **Map**. Ключи - результат применения лямбды к элементам исходной коллекции, элементы - списки из элементов исходной коллекции, соответствующие ключу:
```kt
val words = listOf("a", "cat", "dog")
val lens = words.groupBy { it.length }
// {1=[a], 3=[cat, dog]}
```

Вариант с двумя лямбдами: **keySelector** генерирует ключи, **valueTransform** дополнительно преобразует элементы:
```kt
words.groupBy(
        keySelector = { it.first() }, 
        valueTransform = { it.uppercase() }
)
```


[id](001.005.038)


## 039. Суть функции **groupingBy()**. Ее результат. Сигнатура. Функции, применяемые к результату. Что возвращают.


**groupingBy()** применяет лямбду к элементам коллекции и формирует **Map** как и функция **groupBy()** (ключи - результат лямбды, элементы - списки (группы) из элементов исходной коллекции). Но эта **Map** вычисляется лениво и хранится в объекте **Grouping**:
```kt
inline fun <T, K> Iterable<T>.groupingBy(
    crossinline keySelector: (T) -> K
): Grouping<T, K>
```

Далее к **Grouping** можно применить разные функции:
* **eachCount()** - считает количество элементов в группах. Возвращает **Map**.
* **fold()** и **reduce()** выполняют соответствующие преобразования. Возвращают единственное значение.
* **aggregate()** - универсальный способ обработки через лямбду с ключом, значением, аккумулятором.Возвращает **Map**.
```kt
val numbers = listOf("one", "two", "three", "four", "five", "six")
numbers.groupingBy { it.first() }.eachCount()
// {o=1, t=2, f=2, s=1}
```
```kt
val numbers = listOf(3, 4, 5, 6, 7, 8, 9)

val aggregated = numbers.groupingBy { it % 3 }.aggregate { 
    key, accumulator: StringBuilder?, element, first ->
        if (first) // first element
             StringBuilder().append(key).append(":").append(element)
        else
             accumulator!!.append("-").append(element)
}

println(aggregated.values) // [0:3-6-9, 1:4-7, 2:5-8]
```


[id](001.005.039)


## 040. Функция получения части коллекции **slice()**. Варианты входных параметров. Что если индексы слишком большие.


Формирует новую коллекцию из элементов по заданным индексам.

Индексы можно указать:
* через **IntRange** и соответственно **IntProgression**
* через коллекцию **Iterable**

```kt
val list = listOf("one", "two", "three", "four")
val n1 = list.slice(1..3)
val n2 = list.slice(0..4 step 2)
val n3 = list.slice(setOf(1, 2))
```
Если индексы не попадают в индексы исходной коллекции - исключение.


[id](001.005.040)


## 041. Функции получения части коллекции **take()** и **drop()**. Варианты функций: * смена направления * с предикатами


1. **take()** возвращает новую коллекцию из указанного числа первых элементов исходной. **drop()** - отбрасывает указанное число элементов:
```kt
val numbers = listOf("one", "two", "three", "four", "five", "six")
numbers.take(3)
// [one, two, three]
numbers.drop(2)
// [three, four, five, six] 
```

2. Смена направления:
* **takeLast()** - берет с конца. Порядок соответствует исходной.
* **dropLast()** - отбрасывает с конца

3. Варианты с предикатами:
* **takeWhile()** - выбирает элементы, пока выполняется условие. Первое условие в ложь прекращает выборку.
* **takeLastWhile()** - то же самое, но с конца. Порядок сохраняется.
* **dropWhile()** - отбрасывает пока истинно условие
**dropLastWhile()** - отбрасывает с конца
```kt
numbers.takeWhile { !it.startsWith('f') }
// [one, two, three]
numbers.takeLastWhile { it != "three" }
// [four, five, six]
numbers.dropWhile { it.length == 3 }
// [three, four, five, six]
numbers.dropLastWhile { it.contains('i') }
// [one, two, three, four]
```


[id](001.005.041)


## 042. Функция получения части коллекции **chunked()**. Вариант с обработкой частей сразу.


Разбивает исходную коллекцию на части заданного размера. Возвращает **List** из **List**. Последняя коллекция может быть меньшего размера.
```kt
val nums = (1 .. 12).toList()
val chunks = nums.chunked(3)
```

Можно передать лямбду, которая будет применена к каждому списку:
```kt
val sums = nums.chunked(3) { it.sum() }
```


[id](001.005.042)


## 043. Общая функция получения элемента по позиции.   Аналог для **List**.  Получение первого / последнего элемента коллекции.  Другие варианты: обработка выхода за границы, значения по умолчанию.


Функция **elementAt()** возвращает элемент по указанному индексу. При выходе за пределы - исключение. Допустимы для **Iterable** объектов
```kt
val nums = listOf("one", "two", "three")
val first = nums.elementAt(0)
```
 
Конкретно для списков есть аналог - функция **get()** или **[]**.
 
Есть специальные функции для получения первого элемента **first()** и последнего **last()**.
 
Чтобы избежать исключений при выходе за пределы:
* **elementAtOrNull()** - возвращает `null`
* **elementAtOrElse()** - дополнительно функцию принимает, которая применяется при выходе за пределы к переданному значению
```kt
val over = nums.elementAtOrNull(100) // null
val el = nums.elementAtOrElse(50) { 42 }
```


[id](001.005.043)


## 044. Функции для получения элемента коллекции по условию.  Функции для работы без исключений.


Функции **first()** и **last()** с предикатом возвращают первый / последний элемент, соответствующий условию. Если нет таких элементов - исключение **NoSuchElementException**.
 
Чтобы работать без исключений - **firstOrNull()** / **lastOrNull()** или их аналоги **find()** / **findLast()**
```kt
val numbers = listOf(1, 2, 3, 4, 5)
val a = numbers.firstOrNull { it > 4 }
val b = numbers.findLast { it % 2 == 0 }
```


[id](001.005.044)


## 045. Функции для проверки вхождения элемента / элементов в коллекцию. Какое равенство проверяется.  Функции для проверки коллекции на пустоту.


Функция **contains()** или её оператор **in** возвращает Истина, если в коллекции есть элемент, для которого `equals()` возвращает Истина для проверяемого элемента.
 
Для проверки вхождений элементов коллекции - **containsAll()**: 
```kt
fun <T> Collection<T>.containsAll(
    elements: Collection<T>
): Boolean
``` 
 
```kt
val nums = listOf(1, 2, 3)
val hasTwo = nums.contains(2)
val containsList = nums.containsAll(listOf(2, 3))
```

Проверка на пустоту: **isEmpty()** или **isNotEmpty()**.


[id](001.005.045)


## 046. Виды порядков при сортировке (натуральный и произвольный).  Что такое **Comparable** и **Comparator**.


Два вида порядка (ordering): 
* **natural** (натуральный) - определяется реализацией интерфейса **Comparable**. Определен в классе, неизменен.
* **custom** (произвольный) - реализацией интерфейса **Comparator**. Можно определять любой, независимо от реализации класса. 
 
Интерфейс **Comparable**:
```kt
public interface Comparable<in T> {
    public operator fun compareTo(other: T): Int
}
```
 
Интерфейс **Comparator**:
```kt
public expect fun interface Comparator<T> {
    public fun compare(a: T, b: T): Int
}
```


[id](001.005.046)


## 047. Способы создания экземпляров **Comparator**.


1. Т. к. это функциональный интерфейс можно через их синтаксис:
```kt
val stringComparator = Comparator { s1: String, s2: String -> s1.length - s2.length }
```

2. Используя вспомогательную функцию **compareBy()**:
```kt
inline fun <T> compareBy(
    selector: (T) -> Comparable<*>?
): Comparator<T>
```
Т. е. передаем функцию, которая преобразует исходный элемент в **Comparable** объект:
```kt
listOf("aaa", "bb", "c").sortedWith(compareBy { it.length })
```


[id](001.005.047)


## 048. Функции для сортировки коллекций в натуральном порядке.


**sorted()** или **sortedDescending()** применяются к коллекциям из элементов **Comparable** типа. Возвращают новую отсортированную коллекцию.
```kt
val numbers = listOf("one", "two", "four")
val sorted = numbers.sorted()
``` 


[id](001.005.048)


## 049. Функции для сортировки коллекций в произвольном порядке.


1. **sortedBy()** или **sortedByDescending()** позволяют сортировать в произвольном порядке или не **Comparable**-объекты (ср. с **sorted()**). Принимает функцию, преобразующую элементы в **Comparable**, по которым выполняется сортировка:
```kt
val numbers = listOf("one", "two", "three", "four")
val sorted = numbers.sortedBy { it.length }
```

2. **sortedWith()** сортирует через **Comparator**:
```kt
val numbers = listOf("one", "two", "three", "four")
val sorted = numbers.sortedWith( compareBy { it.length } )
```


[id](001.005.049)


## 050. Функции для изменения порядка элементов в коллекции на обратный. Перемешивание элементов в коллекции.


1. **reversed()** возвращает новую коллекцию, в которой порядок элементов обратный, по сравнению с исходной.
```kt
val list = listOf(1, 3, 2)
val reversed = list.reversed()
// [2, 3, 1]
```

2. **asReversed()** создает *view* исходной коллекции. Если исходная коллекция мутабельна, изменения над исходной отражаются и в перевернутой и наоборот:
```kt
val numbers = mutableListOf(1, 2, 3)
val reversed = numbers.asReversed() // (3, 2, 1)
numbers.add(4)
println(numbers) // (1, 2, 3, 4)
println(reversed) // (4, 3, 2, 1)
```

3. Перемешивание - **shuffled()**. Создает новую коллекцию.


[id](001.005.050)


## 051. Примеры агрегирующих функций для коллекций. Различный варианты получения мин / макс значений.


Агрегирующие функции возвращают единственное значение:
* **minOrNull()** / **maxOrNull()** - `null` для пустых коллекций
* **average()** - среднее для коллекций числовых типов
* **sum()** - аналогично
* **count()** - количество элементов

Дополнительные функции для мин / макс:
* **maxByOrNull()** - принимает функцию-селектор, по значению которой выполняется отбор (возвращается элемент)
* **maxOfOrNull()** - то же самое, но возвращается результат функции
* **maxWithOrNull()** - принимает **Comparator**, через него отбор
* **maxOfWithOrNull()** - принимает селектор, которая преобразует элементы, и компаратор для результатов селектора. Возвращает макс. результат селектора.

```kt
val numbers = listOf(5, 42, 10, 4)
val min3Remainder = numbers.minByOrNull { it % 3 } // 42

val strings = listOf("one", "two", "three", "four")
val longestString = strings.maxWithOrNull(compareBy { it.length }) // three
```

Есть аналоги без **..OrNull**. Выбрасывают исключения на пустых коллекциях.


[id](001.005.051)


## 052. Суть функций **fold()** и **reduce()**. Аналоги для работы с индексами.


Универсальные агрегирующие функции, применяют переданную операцию к элементам коллекции и возвращают полученный результат: 
```kt
inline fun <S, T : S> Iterable<T>.reduce(
    operation: (acc: S, T) -> S
): S
```
```kt
inline fun <T, R> Iterable<T>.fold(
    initial: R,
    operation: (acc: R, T) -> R
): R
```
**fold()** принимает начальное значение и использует его в качестве аккумулятора на первом шаге. У **reduce()** нет начального значения,  на первом шаге операция применяется к первым двум элементам, первый элемент - как аккумулятор. На последующих шагах у обоих функций в аккумулятор передается результат предыдущих шагов.

**reduceIndexed()** / **foldIndexed()** передают индекс в качестве первого элемента операции:
```kt
val sumEven = numbers.foldIndexed(0) { 
    idx, sum, element -> 
        if (idx % 2 == 0) 
            sum + element 
         else sum 
}
```

Вызывают исключения при работе с пустыми коллекциями. Функции  с **..OrNull** - возвращают `null`.


[id](001.005.052)


## 053. Функции записи в коллекцию: добавления элементов в мутабельную коллекцию.


Функции **add()** добавляет элемент в коллекцию.
 
Функция **addAll()** добавляет все элементы из **Iterable**, **Sequence** или **Array**:
 
```kt
val list = mutableListOf(1, 2, 3)
list.add(4)
list.addAll(setOf(5, 6))
```
 
Функция **plusAssign()** или ее оператор **+=** добавляет элемент или коллекцию в конец текущей коллекции:
```kt
val list = mutableListOf(1, 2, 3)
list += listOf(5, 6)
```


[id](001.005.053)


## 054. Функции записи в коллекцию: удаление элементов из коллекции, множественное удаление.  Функция **minusAssign()**.


**remove()** принимает элемент и удаляет первое вхождение этого элемента:
```kt
val list = mutableListOf(1, 2, 3)
list.remove(3)
```
 
Для множественного удаления:
* **removeAll()** - два варианта: с переданной коллекцией или с предикатом (по Истине удаляет)
* **retainAll()** - аналогично, но оставляет переданные элементы или по Истина
* **clear()** - очищает коллекцию
 
Функция **minusAssign()** или ее оператор **-=** удаляет первое вхождение элемента (если передан отдельный элемент) или все элементы (если передана коллекция)
```kt
val nums = listOf(1, 2, 3, 3, 4)
nums -= listOf(3, 4)
// [1, 2]
```


[id](001.005.054)


## 055. Разница между фукнкциями **plus** / **minus** и **plusAssign** / **minusAssign**


Функция **plus()** (оператор **+**) добавляет элемент / элементы из коллекции к текущей коллекции и возвращает новую коллекцию.
 
Функция **plusAsign()** (оператор **+=**) добавляет элемент / элементы из коллекции к текущей **мутабельно** коллекции без создания новой коллекции.
 
Функции **minus()** / **minusAssign()** - аналогично с удалением.
 
```kt
val list1 = listOf(1, 2, 3)
val list2 = list1 + 4
 
val list3 = mutableListOf(1, 2, 3)
list3 += 4
```


[id](001.005.055)


## 056. Специфичные функции для списков: получения элементов по индексу, получение части списка.


Кроме доступных для всех коллекций **elementAt()**, **first()**, **last()** и др., есть специфичные для списков.
 
**get()** или **[]** - возвращает элемент или исключение при выходе за пределы.
 
**getOrNull()** - возвращает `null` при выходе за пределы. **getOrElse()** - с функцией, возвращающей значение по умолчанию.
```kt
val list = listOf(1, 2, 3)
val v = list.getOrElse(10) { 42 }
```
 
**sublist()** - возвращает *view* (изменения в исходном отражаются) текущего списка с начального индекса (включительно) по конечный индекс (не включая):
```kt
val nums = (0 .. 10).toList()
val a = nums.subList(3, 6) // [3, 4, 5]
```


[id](001.005.056)


## 057. Специфичные функции для списков: поиск позиции элемента (линейный и бинарный поиск).  Бинарный поиск: что возвращает, условия применения. Варианты функций бинарного поиска.


1. **indexOf()** и **lastIndexOf()** - возвращают индекс первого / последнего элемента элемента, равного переданному. Если нет такого элемента возвращают `-1`
 
Есть версии с предикатами **indexOfFirst()** / **indexOfLast()**
 
```kt
val list = listOf(10, 30, 20, 40)
val i1 = list.indexOf(30) // 1
val i2 = list.indexOfFirst { it > 30 } // 3
```
 
2. Для бинарного поиска коллекция должна быть отсортированна по возрастанию. Если нет - возвращает случайный результат. Если нашел элемент - возвращает его индекс. Если нет - возвращает `(- индекс куда бы встал этот элемент - 1)`, т. е. всегда меньше 0.
 
Основная функция **binarySearch()**. Варианты:
* вызов на списке **Comparable**-объектов
* вызов с компаратором
* вызов с *comparison*-функцией `(T) -> Int`, преобразующей элементы в `Int`. Совпадения - если функция возвращает 0. Коллекция нужно отсортировать по результату функции предварительно.
 
```kt
val list = listOf(1, 2, 3, 4)
val a = list.binarySearch(3)
 
val words = mutableListOf("w", "th", "two", "thou", "three")
val a = words.binarySearch("th", compareBy { it.length })
```


[id](001.005.057)


## 058. Специфичные функции для списков: добавление в позицию, замена элементов, удаление из позиции


1. Кроме стандартного добавления в конец коллекции, для списков можно добавлять в конкретную позицию со сдвигом элементов:
 
```kt
val list = mutableListOf("1", "5", "6")
 
list.add(1, "2")
list.addAll(2, listOf("3", "4"))
```
 
2. Замена элемента в конкретной позиции - **set()** и оператор **[]**. Замена всех элементов - **fill()**
```kt
val list = mutableListOf(1, 2, 3, 4, 5)
list[1] = 42
list.fill(0)
```  
 
3. Удаление элемента с конкретной позиции - **removeAt()**. Элементы справа - сдвигаются (ср. с **remove()**, которая удаляет значение). Возвращает удаленное значение.
 
```kt
val list = mutableListOf(1, 2, 3, 4, 5)
list.removeAt(1)
// [1, 3, 4, 5]
```


[id](001.005.058)


## 059. Особенности операций сортировки для мутабельных списков.


Операции для read-only списков **sorted()**, **shuffled()** и т. п. возвращают новые экземпляры коллекций.
 
Операции без **ed/d** применимы к мутабельным спискам и изменяют текущий список вместо возврата нового: 
```kt 
val list = mutableListOf(1, 2, 4, 3) 
list.sort()
listSortBy { it }
```


[id](001.005.059)


## 060. Специфичные операции для **Set**: объединение, пересечение, разность. Пример сигнатур. Что с упорядоченностью. Применение к другим видам коллекций.


**union()** - возвращает результат объединения двух коллекций или массива с коллекцией. Результат - **Set**.
```kt
infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T>
infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T>
```

**intersect()** - возвращает **Set** из элементов, присутствующих в обоих коллекциях.

**subset()** - возвращает **Set** из элементов, присутствующих только в первой коллекции.

```kt
val numbers = setOf("one", "two", "three")
val a = numbers intersect setOf("two", "one")
```


[id](001.005.060)


## 061. Функции получения элементов **Map**: стандартная, что возвращает. Другие варианты для работы с отсутствующими.


Стандартная **get()** или ее оператор **[]**. Возвращает `null`, если ключа нет.

Другие функции с обработкой отсутствия ключа:
* **getValue()** вызывает исключение, если ключа нет.
* **getOrElse()** - возращает результат переданной функции
* **getOrDefault()** - возвращает переданное значение

```kt
val m = mapsOf("one" to 1, "two" to 2)
val x1 = m.get("one") // 1
val x2 = m.getOrDefault("four", 42) // 42
val x3 = m.get("four") // null
```


[id](001.005.061)


## 062. Как получить доступ к ключам и значениям **Map**. Их типы.


Через свойства **keys** (возвращает **Set**) и **values** (возвращает **List**):
```kt
val numbersMap = mapOf("one" to 1, "two" to 2, "three" to 3)
val k = numbersMap.keys // [one, two, three]
val v = numbersMap.values // [1, 2, 3]
```


[id](001.005.062)


## 063. Функции для фильтрации **Map**: особенности стандартной и специфичные.


1. На вход предиката стандартной функции **filter()** - **Pair** из ключа и значения:
```kt
val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key11" to 11)
val filteredMap = numbersMap.filter { (key, value) -> key.endsWith("1") &amp;&amp; value > 10}
// {key11=11}
```

2. Есть специальные для фильтров только по ключам **filterKeys()** и только по значениям **filterValues()**:
```kt
val filteredKeysMap = numbersMap.filterKeys { it.endsWith("1") }
val filteredValuesMap = numbersMap.filterValues { it < 10 }
```


[id](001.005.063)


## 064. Особенности функции **plus()** / **minus()** для **Map**: варианты параметров, суть.


1. **plus()** (**+**) создает новую Map, содержащую элементы исходной и добавленные элементы из второго параметра. Вторым параметром:
* один элемент **Pair**
* коллекция **Pair**
* другая **Map**

Если есть одинаковые ключи - из коллекции справа значения будут вставлены.
```kt
val numbersMap = mapOf("one" to 1, "two" to 2, "three" to 3)
val m1 = numbersMap + Pair("one", 10) // {one=10, two=2, three=3}
val m2 = numbersMap + mapOf("five" to 5, "one" to 11)
```
2. **minus()** создает новую Map, в которой исключены ключи, указанные справа: отдельным значением или в коллекции:
```kt
val numbersMap = mapOf("one" to 1, "two" to 2, "three" to 3)
val m1 = numbersMap - "one" // {two=2, three=3}
val m2 = numbersMap - listOf("two", "four") // {one=1, three=3}
```


[id](001.005.064)


## 065. Как добавить элемент в существующую **Map**: одного, нескольких


1. Добавление элемента в мутабельную **Map** - **put()**. Для упорядоченных (`LinkedHashMap` которая по умолчанию) - вставляет в конец:
```kt
val numbersMap = mutableMapOf("one" to 1, "two" to 2)
numbersMap.put("three", 3)
```

2. Добавить несколько - **putAll()**. Принимает группу **Pair**: Iterable, Array, Sequence:
```kt
val numbersMap = mutableMapOf("one" to 1, "two" to 2, "three" to 3)
numbersMap.putAll(setOf("four" to 4, "five" to 5))
```
3. Через функции **set()** / **[]** и **plusAssign()** / **+=**:
```kt
val numbersMap = mutableMapOf("one" to 1, "two" to 2)
numbersMap["three"] = 3     // calls numbersMap.put("three", 3)
numbersMap += mapOf("four" to 4, "five" to 5)
```

Все функции перезаписывают значения в существующих ключах.


[id](001.005.065)


## 066. Удаление записей из **Map**: * удаление по ключам/значениям * отдельно по ключам и значениям * через **-=**


1. В функцию **remove()** можно передать ключ () или пару ключ/значение (удаление - только при совпадении и ключа, и значения).
```kt
val numbersMap = mutableMapOf("one" to 1, "two" to 2, "three" to 3)
numbersMap.remove("one")
numbersMap.remove("three", 4) // ничего не удаляет
```    
2. Удаление через ключи или значения. Для значений - удаляет только первое вхождение (но можно любым способ для коллекций удалять все)
```kt
val numbersMap = mutableMapOf("one" to 1, "two" to 2, "three" to 3, "threeAgain" to 3)
numbersMap.keys.remove("one")
numbersMap.values.remove(3)
numbersMap.values.removeAll(listOf(3))
```

3. Удаление через функцию **minusAssign()**:
```kt
val numbersMap = mutableMapOf("one" to 1, "two" to 2, "three" to 3)
numbersMap -= "two"
numbersMap -= "five"             //doesn't remove anything
```


[id](001.005.066)