## 001. Что такое Dependency Injection? Типы.


**DI** - техника создания ПО, когда объекты не создают свои зависимости внутри себя. Вместо этого они объявляют зависимости, в которых нуждаются, и внешний объект / фрейморк предоставляет им эти зависимости

Примеры:
* **(без DI)** внутри объекта переменная типа класса и создание экземпляра через `new()`.
* **(ручной DI)** переменная имеет тип интерфейса. Присваивание - через конструктор. Зависимость внедряется извне при создании объекта.

Типы:
* внедрение через конструктор
* внедрение через сеттер
* внедрение через интерфейс (клиент реализует интерфейс, который определяет как будет внедрятся зависимость (например через метод-сеттер))


[id](003.002.001)


## 002. Что такое интерфейсы, преимущество их использования. Почему интерфейсы рекомендуются для Spring бинов.


(ООП) **Интерфейc** - описание действий, которые может выполнять объект. Способ заставить объект, реализующий интерфейс выполнять действия.

(Java) **Интерфейс** - ссылочный тип, содержащий коллекцию абстрактных методов. Класс, реализующий интерфейс, обязан реализовать эти методы или объявить их абстрактными.

Преимущества:

* разделяют контракт и его реализацию
* позволяют определить контракт между объектами
* увеличивают взаимозаменяемость объектов
* упрощают тестирование

Преимущества интерфейсов для Spring:

* позволяют использовать JDK Dynamic Proxy
* скрывают реализации
    - интерфейс публичный, реализации - в пределах пакета
    - так вынуждаем использовать контракты, а не реализации
* позволяют легко менять бины (квалификаторы и др.)


[id](003.002.002)


## 003. Что такое Application Context? Задачи.


Это центральная часть Spring приложения. Это интерфейс. Наследует несколько других интерфейсов.

Отвечает за:

* инициализацию и конфигурацию бинов
* управление жизненным циклом бинов
* загрузку ресурсов (интерфейс `ResourceLoader`)
* отправку событий зарегистрированным обработчикам событий
* это фабрика бинов (интерфейс `BeanFactory`)
* доступ к `Environment` для получения свойств

Реализации **ApplicationContext**:

* **AnnotationConfigApplicationContext** - конфигурация на аннотациях
* **AnnotationConfigWebApplicationContext** - то же, но веб-приложения, для контейнера сервлетов
* **ClassPathXmlApplicationContext** - xml-конфигурация, файлы конфигурации в classpath
* **FileSystemXmlApplicationContext** - то же, но файлы конфигурации в файловой системе


[id](003.002.003)


## 004. Общий алгоритм создания AnnotationConfigApplicationContext и получения бинов


Общий алгоритм:
* создать контекст
* определить бины (несколько способов)
* создать и загрузить бины в контекст (обновить конфигурацию)
* получить бин

Необходимые  зависимости: **spring-core** и **spring-context**.

Например есть бин:
```kt
package bean

interface Printable {
    fun print()
}

@Component
class SimpleBean : Printable {
    override fun print() {
        println("Hello, I am SimpleBean")
    }
}
```
Создаем контекст:
```kt
// 1. создаем контекст
val context = AnnotationConfigApplicationContext()
// 2. описываем размещение бинов (например через пакет)
context.scan("com.example.bean")
// 3. загружаем бины
context.refresh()
// 4. получаем бин
val printableBean = context.getBean<Printable>()
```


[id](003.002.004)


## 005. Способы определения конфигурации бинов при создании AnnotationConfigApplicationContext


Две группы методов:
* сканирование пакетов и поиск бинов (метод **scan()**)
    - классы должны быть с аннотацией **@Component** и производными
* регистрация бинов через классы (метод **register()**)
    - аннотации не нужны

Далее обновляем контекст и можем получать бины.

1. **Сканирование по пакетам**:
```kt
val ctx = AnnotationConfigApplicationContext()
// в пакете должны быть классы с аннотациями
ctx.scan("com/example/bean")
ctx.refresh()
val bean = ctx.getBean<Printable>()
bean.print()
```
2. **Регистрация бинов через классы**:
```kt
val ctx = AnnotationConfigApplicationContext()
// класс SimpleBean может быть без аннотаций
ctx.register(SimpleBean::class.java)
ctx.refresh()
val bean = ctx.getBean<Printable>()
bean.print()
```


[id](003.002.005)


## 006. Способы настройки контекста через конструктор


В зависимости от параметров конструктора, внутри вызываются **scan()/refresh()** или **register()/refresh()**.

Параметры конструкторов:

1. **Пакеты**, содержащие бины. Внутри конструктора вызываются методы **scan()** и **refresh()**. Бины должны быть с аннотацией **@Component**:
```kt
val ctx = AnnotationConfigApplicationContext("com.example.bean")
val printableBean = ctx.getBean<Printable>()
```
2. **Конфигурационный класс с `@ComponentScan`**. Тем самым определяем пакеты для сканирования. Бины должны быть с аннотацией **@Component**.
```kt
// по умолчанию сканируются 
// пакеты, где класс расположен
@ComponentScan
class BeanPackageConfig {
}
```
```kt
val ctx = AnnotationConfigApplicationContext(BeanPackageConfig::class.java)
val bean = ctx.getBean<Printable>()
```
3. **Перечень классов-бинов**:
```kt
// аннотации над SimpleBean не нужны
val ctx = AnnotationConfigApplicationContext(SimpleBean::class.java)
val bean = ctx.getBean<Printable>()
```
4. **Перечень классов, создающих бины**:
```kt
class BeanConfig {
    @Bean
    fun getBean(): Printable = SimpleBean()
}
...
val ctx = AnnotationConfigApplicationContext(BeanConfig::class.java)
val bean = ctx.getBean<Printable>()
```


[id](003.002.006)


## 007. Контейнер, его жизненный цикл. BeanFactoryPostProcessor и BeanPostProcessor.


Контейнер - окружение, предоставляющее средства для управления бинами. Управляет жизненным циклом бинов, дает доступ к **ApplicationContext**.

Жизненный цикл:
1. Запуск приложения
2. Создание контейнера
3. Контейнер читает конфигурацию
4. Создание **описаний** (**definition**) бинов
5. Описания бинов обрабатываются **BeanFactoryPostProcessor**
6. Создание экземпляров бинов
7. Настройка бинов: свойства, внедрение зависимостей
8. Вызов реализаций **BeanPostProcessor** (обрабатывает экземпляры)
9. Приложение запущено
10. Завершение работы приложения
11. Закрытие контекста
12. Вызов методов завершения жизненного цикла бинов

**BeanFactoryPostProcessor** vs **BeanPostProcessor**:
* **BFPP** вызывается после того как прочитаны все определения бинов, до создания экземпляров, работает **с описаниями бинов**
* **BPP** работает **с экземплярами бинов**, вызывается после создания экземпляра:
    - в начале работы контейнера 
    - в процессе работы приложения, если загрузка бина - по требованию


[id](003.002.007)


## 008. Способы управления жизненным циклом бинов. Порядок вызова методов


Можно различать по месту описания логики:

1. **Внутри бина**:
* Методы с JSR-350 аннотациями **@PostConstruct** и **@PreDestroy** (нужны доп. зависимости `javax.annotation`)
* Реализация интерфейсов **InitializingBean** и **DisposableBean**

2. **Вне бина, но используются методы бина**:

При описании бина через аннотацию **@Bean(initMethod=.., destroyMethod=..)**

3. Полностью **независимо от бина**:

Реализация интерфейса **BeanPostProcessor**
* создать бин такого типа
* будут вызваны методы интерфейса для каждого экземпляра бина
* в параметрах есть доступ к имени бина и объекту

Порядок вызовов **при создании** бина:
* создаются бины
* настраиваются свойства, внедряются зависимости
* вызывается **BPP::postProcessBeforeInitialization()**
* вызывается метод с **@PostConstruct**
* вызывается метод **InitializingBean::afterPropertiesSet()**
* вызывается метод из **@Bean(initMethod=..)**
* вызывается **BPP::postProcessAfterInitialization()**

Порядок вызовов **при уничтожении** бина:
* контекст уничтожается, и вместе с ним уничтожаются бины
* вызывается метод с **@PreDestroy**
* вызывается метод **DisposableBean::destroy()**
* вызывается метод из **@Bean(destroyMethod=...)**


[id](003.002.008)


## 009. Примеры способов управления жизненным циклом бинов.


1. **@PostConstruct/@PreDestroy**:
```kt
class SimpleBean {
    @PostConstruct
    fun init() {
        println("2.1 Post construct done!")
    }
    @PreDestroy
    fun preDestroy() {
        println("3.1 Pre destroy done!")
    }
}
```
2. **InitializingBean/DisposableBean**:
```kt
class SimpleBean: InitializingBean, DisposableBean {
    override fun afterPropertiesSet() {
        println("2.2 afterPropertiesSet")
    }
    override fun destroy() {
        println("3.2 destroy done!")
    }
}
```
3. **@Bean(initMethod=.., destroyMethod=..)**:
```kt
@Component
class SimpleBean {
    fun initMethod() {
        println("init method")
    }
    fun destroyMethod() {
        println("destroy method")
    }
}

class BeanConfig {
    @Bean(initMethod = "initMethod", destroyMethod = "destroyMethod")
    fun getBean(): Printable = SimpleBean()
}

fun main(args: Array<String>) {
    val ctx = AnnotationConfigApplicationContext(BeanConfig::class.java)
    ctx.close()
}
```
4. **BeanPostProcessor**:
```kt
@Component
class BeanPostProcessorImpl: BeanPostProcessor {
    override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
        println("BPP:ppBeforeI $beanName")
        return bean
    }
    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        println("BPP:ppAfterI $beanName")
        return bean
    }
}
```


[id](003.002.009)


## 010. Способы закрытия контекста.


Если не закрыть правильно, не будут вызваны методы жизненного цикла на уничтожение бинов (@`PreDestroy` и т. п.)

* не веб-приложение:
    - (рекомендуется) установить хук **ConfigurableApplicationContext::registerShutdownHook**
    - вызвать **ConfigurableApplicationContext::close**
* веб-приложение:
    - **ContextLoaderListener** автоматически закроет контекст, когда веб-контейнер остановит приложение
* SpringBoot:
    - **ApplicationContext** будет автоматически остановлен
    - Shutdown хук регистрируется автоматически
    - **ContextLoaderListener** также автоматически закрывает контекст в веб-приложении 

**Кратко**:
* веб, SpringBoot - закроют автоматом
* в остальных - `ctx.registerShutdownHook()` 


[id](003.002.010)


## 011. Виды DI: с помощью программной конфигурации, с помощью аннотаций.


1. **Программная конфигурация**: Все бины объявляются в классе-конфигурации (с аннотацией **@Configuration**) c помощью аннотации **@Bean** над методами. Для внедрения зависимостей используется **@Autowired**
```kt
@Configuration
class AppConfig {
    @Bean
    fun getBean(): Printable = SimpleBean()
}
```
Собственно классы бинов не имеют никаких аннотаций.

На основании конфигурации создается контекст:
```kt
val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
```
2. **Через аннотации**: Создаем классы-бины с аннотацией **@Component**. Внутри можно внедрять зависимости через **@Autowired**.
```kt
@Component
class SimpleBean {
    ...
}
```
Далее любым способом настраиваем сканирование, например через класс с **@ComponentScan** и создаем контекст.
```kt
@ComponentScan
class AppPackageConfig {
    // пусто
}
fun main() {
    val ctx = AnnotationConfigApplicationContext(AppPackageConfig::class.java)
}
```


[id](003.002.011)


## 012.  Варианты сканирования компонентов (@ComponentScan)


1. Можно просто указать аннотацию **@ComponentScan** без уточнений, тогда целью сканирования будет пакет, где расположен класс-конфигурация и вложенные пакеты:
```java
@ComponentScan
public class ApplicationConfiguration {...}
```
2. Можно указать конкретный пакет для сканирования:
```java
@ComponentScan(basePackage="a.b.x")
public class ApplicationConfiguration {...}
```
3. Класс, по пакету которого будет проходить сканирование:
```java
@ComponentScan(basePackageClasses = SomeBean.class)
public class ApplicationConfiguration {...}
```
4. Можно еще дополнительно фильтры:
```kt
@ComponentScan(
   basePackages = "a.b.c",
   includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean.*"),
   excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Bean1.*")
```


[id](003.002.012)


## 013. Что такое стереотипные аннотации. Отличие от @Bean. Что такое мета-аннотации.


**Стереотипные аннотации** - аннотации, применяемые к классу, для описания его роли. Spring создает бины для классов, помеченных такими аннотациями. 

Сравнение с **@Bean**: **@Bean** - аннотация для метода, стереотипные аннотации - для типов (классов)

Примеры:

* **@Component** - компонент общего назначения
* **@Service** - класс, содержащий бизнес-логику
* **@Repository** - класс, использующийся для доступа к БД
* **@Controller** - класс контроллер, обычно в веб-приложении

С точки зрения контейнера все эти виды равнозначны, и только разработчик определяет их смысл.

**Мета-аннотации** - аннотации, состоящие из других аннотаций. Например - **@RestController** = **@Controller** + **@ResponseBody**.


[id](003.002.013)